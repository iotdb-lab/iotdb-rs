// Autogenerated by Thrift Compiler (0.16.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use crate::common;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSProtocolVersion(pub i32);

impl TSProtocolVersion {
  pub const IOTDB_SERVICE_PROTOCOL_V1: TSProtocolVersion = TSProtocolVersion(0);
  pub const IOTDB_SERVICE_PROTOCOL_V2: TSProtocolVersion = TSProtocolVersion(1);
  pub const IOTDB_SERVICE_PROTOCOL_V3: TSProtocolVersion = TSProtocolVersion(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::IOTDB_SERVICE_PROTOCOL_V1,
    Self::IOTDB_SERVICE_PROTOCOL_V2,
    Self::IOTDB_SERVICE_PROTOCOL_V3,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSProtocolVersion> {
    let enum_value = i_prot.read_i32()?;
    Ok(TSProtocolVersion::from(enum_value))
  }
}

impl From<i32> for TSProtocolVersion {
  fn from(i: i32) -> Self {
    match i {
      0 => TSProtocolVersion::IOTDB_SERVICE_PROTOCOL_V1,
      1 => TSProtocolVersion::IOTDB_SERVICE_PROTOCOL_V2,
      2 => TSProtocolVersion::IOTDB_SERVICE_PROTOCOL_V3,
      _ => TSProtocolVersion(i)
    }
  }
}

impl From<&i32> for TSProtocolVersion {
  fn from(i: &i32) -> Self {
    TSProtocolVersion::from(*i)
  }
}

impl From<TSProtocolVersion> for i32 {
  fn from(e: TSProtocolVersion) -> i32 {
    e.0
  }
}

impl From<&TSProtocolVersion> for i32 {
  fn from(e: &TSProtocolVersion) -> i32 {
    e.0
  }
}

//
// TSQueryDataSet
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSQueryDataSet {
  pub time: Vec<u8>,
  pub value_list: Vec<Vec<u8>>,
  pub bitmap_list: Vec<Vec<u8>>,
}

impl TSQueryDataSet {
  pub fn new(time: Vec<u8>, value_list: Vec<Vec<u8>>, bitmap_list: Vec<Vec<u8>>) -> TSQueryDataSet {
    TSQueryDataSet {
      time,
      value_list,
      bitmap_list,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSQueryDataSet> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_2: Option<Vec<Vec<u8>>> = None;
    let mut f_3: Option<Vec<Vec<u8>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = i_prot.read_bytes()?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = i_prot.read_bytes()?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSQueryDataSet.time", &f_1)?;
    verify_required_field_exists("TSQueryDataSet.value_list", &f_2)?;
    verify_required_field_exists("TSQueryDataSet.bitmap_list", &f_3)?;
    let ret = TSQueryDataSet {
      time: f_1.expect("auto-generated code should have checked for presence of required fields"),
      value_list: f_2.expect("auto-generated code should have checked for presence of required fields"),
      bitmap_list: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSQueryDataSet");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("time", TType::String, 1))?;
    o_prot.write_bytes(&self.time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("valueList", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.value_list.len() as i32))?;
    for e in &self.value_list {
      o_prot.write_bytes(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("bitmapList", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.bitmap_list.len() as i32))?;
    for e in &self.bitmap_list {
      o_prot.write_bytes(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSQueryNonAlignDataSet
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSQueryNonAlignDataSet {
  pub time_list: Vec<Vec<u8>>,
  pub value_list: Vec<Vec<u8>>,
}

impl TSQueryNonAlignDataSet {
  pub fn new(time_list: Vec<Vec<u8>>, value_list: Vec<Vec<u8>>) -> TSQueryNonAlignDataSet {
    TSQueryNonAlignDataSet {
      time_list,
      value_list,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSQueryNonAlignDataSet> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<Vec<u8>>> = None;
    let mut f_2: Option<Vec<Vec<u8>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = i_prot.read_bytes()?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = i_prot.read_bytes()?;
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSQueryNonAlignDataSet.time_list", &f_1)?;
    verify_required_field_exists("TSQueryNonAlignDataSet.value_list", &f_2)?;
    let ret = TSQueryNonAlignDataSet {
      time_list: f_1.expect("auto-generated code should have checked for presence of required fields"),
      value_list: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSQueryNonAlignDataSet");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timeList", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.time_list.len() as i32))?;
    for e in &self.time_list {
      o_prot.write_bytes(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("valueList", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.value_list.len() as i32))?;
    for e in &self.value_list {
      o_prot.write_bytes(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSTracingInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSTracingInfo {
  pub activity_list: Vec<String>,
  pub elapsed_time_list: Vec<i64>,
  pub series_path_num: Option<i32>,
  pub seq_file_num: Option<i32>,
  pub un_seq_file_num: Option<i32>,
  pub sequence_chunk_num: Option<i32>,
  pub sequence_chunk_point_num: Option<i64>,
  pub unsequence_chunk_num: Option<i32>,
  pub unsequence_chunk_point_num: Option<i64>,
  pub total_page_num: Option<i32>,
  pub overlapped_page_num: Option<i32>,
}

impl TSTracingInfo {
  pub fn new<F3, F4, F5, F6, F7, F8, F9, F10, F11>(activity_list: Vec<String>, elapsed_time_list: Vec<i64>, series_path_num: F3, seq_file_num: F4, un_seq_file_num: F5, sequence_chunk_num: F6, sequence_chunk_point_num: F7, unsequence_chunk_num: F8, unsequence_chunk_point_num: F9, total_page_num: F10, overlapped_page_num: F11) -> TSTracingInfo where F3: Into<Option<i32>>, F4: Into<Option<i32>>, F5: Into<Option<i32>>, F6: Into<Option<i32>>, F7: Into<Option<i64>>, F8: Into<Option<i32>>, F9: Into<Option<i64>>, F10: Into<Option<i32>>, F11: Into<Option<i32>> {
    TSTracingInfo {
      activity_list,
      elapsed_time_list,
      series_path_num: series_path_num.into(),
      seq_file_num: seq_file_num.into(),
      un_seq_file_num: un_seq_file_num.into(),
      sequence_chunk_num: sequence_chunk_num.into(),
      sequence_chunk_point_num: sequence_chunk_point_num.into(),
      unsequence_chunk_num: unsequence_chunk_num.into(),
      unsequence_chunk_point_num: unsequence_chunk_point_num.into(),
      total_page_num: total_page_num.into(),
      overlapped_page_num: overlapped_page_num.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSTracingInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<Vec<i64>> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i32> = None;
    let mut f_7: Option<i64> = None;
    let mut f_8: Option<i32> = None;
    let mut f_9: Option<i64> = None;
    let mut f_10: Option<i32> = None;
    let mut f_11: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = i_prot.read_string()?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_5 = i_prot.read_i64()?;
            val.push(list_elem_5);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i64()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i32()?;
          f_11 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSTracingInfo.activity_list", &f_1)?;
    verify_required_field_exists("TSTracingInfo.elapsed_time_list", &f_2)?;
    let ret = TSTracingInfo {
      activity_list: f_1.expect("auto-generated code should have checked for presence of required fields"),
      elapsed_time_list: f_2.expect("auto-generated code should have checked for presence of required fields"),
      series_path_num: f_3,
      seq_file_num: f_4,
      un_seq_file_num: f_5,
      sequence_chunk_num: f_6,
      sequence_chunk_point_num: f_7,
      unsequence_chunk_num: f_8,
      unsequence_chunk_point_num: f_9,
      total_page_num: f_10,
      overlapped_page_num: f_11,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSTracingInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("activityList", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.activity_list.len() as i32))?;
    for e in &self.activity_list {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("elapsedTimeList", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.elapsed_time_list.len() as i32))?;
    for e in &self.elapsed_time_list {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.series_path_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("seriesPathNum", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.seq_file_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("seqFileNum", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.un_seq_file_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("unSeqFileNum", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.sequence_chunk_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("sequenceChunkNum", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.sequence_chunk_point_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("sequenceChunkPointNum", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.unsequence_chunk_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("unsequenceChunkNum", TType::I32, 8))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.unsequence_chunk_point_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("unsequenceChunkPointNum", TType::I64, 9))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.total_page_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("totalPageNum", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.overlapped_page_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("overlappedPageNum", TType::I32, 11))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSExecuteStatementResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSExecuteStatementResp {
  pub status: common::TSStatus,
  pub query_id: Option<i64>,
  pub columns: Option<Vec<String>>,
  pub operation_type: Option<String>,
  pub ignore_time_stamp: Option<bool>,
  pub data_type_list: Option<Vec<String>>,
  pub query_data_set: Option<TSQueryDataSet>,
  pub non_align_query_data_set: Option<TSQueryNonAlignDataSet>,
  pub column_name_index_map: Option<BTreeMap<String, i32>>,
  pub sg_columns: Option<Vec<String>>,
  pub alias_columns: Option<Vec<i8>>,
  pub tracing_info: Option<TSTracingInfo>,
}

impl TSExecuteStatementResp {
  pub fn new<F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12>(status: common::TSStatus, query_id: F2, columns: F3, operation_type: F4, ignore_time_stamp: F5, data_type_list: F6, query_data_set: F7, non_align_query_data_set: F8, column_name_index_map: F9, sg_columns: F10, alias_columns: F11, tracing_info: F12) -> TSExecuteStatementResp where F2: Into<Option<i64>>, F3: Into<Option<Vec<String>>>, F4: Into<Option<String>>, F5: Into<Option<bool>>, F6: Into<Option<Vec<String>>>, F7: Into<Option<TSQueryDataSet>>, F8: Into<Option<TSQueryNonAlignDataSet>>, F9: Into<Option<BTreeMap<String, i32>>>, F10: Into<Option<Vec<String>>>, F11: Into<Option<Vec<i8>>>, F12: Into<Option<TSTracingInfo>> {
    TSExecuteStatementResp {
      status,
      query_id: query_id.into(),
      columns: columns.into(),
      operation_type: operation_type.into(),
      ignore_time_stamp: ignore_time_stamp.into(),
      data_type_list: data_type_list.into(),
      query_data_set: query_data_set.into(),
      non_align_query_data_set: non_align_query_data_set.into(),
      column_name_index_map: column_name_index_map.into(),
      sg_columns: sg_columns.into(),
      alias_columns: alias_columns.into(),
      tracing_info: tracing_info.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSExecuteStatementResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<common::TSStatus> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<Vec<String>> = None;
    let mut f_7: Option<TSQueryDataSet> = None;
    let mut f_8: Option<TSQueryNonAlignDataSet> = None;
    let mut f_9: Option<BTreeMap<String, i32>> = None;
    let mut f_10: Option<Vec<String>> = None;
    let mut f_11: Option<Vec<i8>> = None;
    let mut f_12: Option<TSTracingInfo> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_6 = i_prot.read_string()?;
            val.push(list_elem_6);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_7 = i_prot.read_string()?;
            val.push(list_elem_7);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let val = TSQueryDataSet::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = TSQueryNonAlignDataSet::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, i32> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_8 = i_prot.read_string()?;
            let map_val_9 = i_prot.read_i32()?;
            val.insert(map_key_8, map_val_9);
          }
          i_prot.read_map_end()?;
          f_9 = Some(val);
        },
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_10 = i_prot.read_string()?;
            val.push(list_elem_10);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        11 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i8> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_11 = i_prot.read_i8()?;
            val.push(list_elem_11);
          }
          i_prot.read_list_end()?;
          f_11 = Some(val);
        },
        12 => {
          let val = TSTracingInfo::read_from_in_protocol(i_prot)?;
          f_12 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSExecuteStatementResp.status", &f_1)?;
    let ret = TSExecuteStatementResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query_id: f_2,
      columns: f_3,
      operation_type: f_4,
      ignore_time_stamp: f_5,
      data_type_list: f_6,
      query_data_set: f_7,
      non_align_query_data_set: f_8,
      column_name_index_map: f_9,
      sg_columns: f_10,
      alias_columns: f_11,
      tracing_info: f_12,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSExecuteStatementResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.query_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryId", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("columns", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.operation_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("operationType", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ignore_time_stamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("ignoreTimeStamp", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.data_type_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("dataTypeList", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_data_set {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryDataSet", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.non_align_query_data_set {
      o_prot.write_field_begin(&TFieldIdentifier::new("nonAlignQueryDataSet", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_name_index_map {
      o_prot.write_field_begin(&TFieldIdentifier::new("columnNameIndexMap", TType::Map, 9))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::I32, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_i32(*v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sg_columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("sgColumns", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.alias_columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("aliasColumns", TType::List, 11))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I08, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i8(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tracing_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("tracingInfo", TType::Struct, 12))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSOpenSessionResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSOpenSessionResp {
  pub status: common::TSStatus,
  pub server_protocol_version: TSProtocolVersion,
  pub session_id: Option<i64>,
  pub configuration: Option<BTreeMap<String, String>>,
}

impl TSOpenSessionResp {
  pub fn new<F3, F4>(status: common::TSStatus, server_protocol_version: TSProtocolVersion, session_id: F3, configuration: F4) -> TSOpenSessionResp where F3: Into<Option<i64>>, F4: Into<Option<BTreeMap<String, String>>> {
    TSOpenSessionResp {
      status,
      server_protocol_version,
      session_id: session_id.into(),
      configuration: configuration.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSOpenSessionResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<common::TSStatus> = None;
    let mut f_2: Option<TSProtocolVersion> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TSProtocolVersion::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_12 = i_prot.read_string()?;
            let map_val_13 = i_prot.read_string()?;
            val.insert(map_key_12, map_val_13);
          }
          i_prot.read_map_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSOpenSessionResp.status", &f_1)?;
    verify_required_field_exists("TSOpenSessionResp.server_protocol_version", &f_2)?;
    let ret = TSOpenSessionResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      server_protocol_version: f_2.expect("auto-generated code should have checked for presence of required fields"),
      session_id: f_3,
      configuration: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSOpenSessionResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("serverProtocolVersion", TType::I32, 2))?;
    self.server_protocol_version.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.session_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.configuration {
      o_prot.write_field_begin(&TFieldIdentifier::new("configuration", TType::Map, 4))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSOpenSessionReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSOpenSessionReq {
  pub client_protocol: TSProtocolVersion,
  pub zone_id: String,
  pub username: Option<String>,
  pub password: Option<String>,
  pub configuration: Option<BTreeMap<String, String>>,
}

impl TSOpenSessionReq {
  pub fn new<F3, F4, F5>(client_protocol: TSProtocolVersion, zone_id: String, username: F3, password: F4, configuration: F5) -> TSOpenSessionReq where F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<BTreeMap<String, String>>> {
    TSOpenSessionReq {
      client_protocol,
      zone_id,
      username: username.into(),
      password: password.into(),
      configuration: configuration.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSOpenSessionReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSProtocolVersion> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSProtocolVersion::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_14 = i_prot.read_string()?;
            let map_val_15 = i_prot.read_string()?;
            val.insert(map_key_14, map_val_15);
          }
          i_prot.read_map_end()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSOpenSessionReq.client_protocol", &f_1)?;
    verify_required_field_exists("TSOpenSessionReq.zone_id", &f_2)?;
    let ret = TSOpenSessionReq {
      client_protocol: f_1.expect("auto-generated code should have checked for presence of required fields"),
      zone_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      username: f_3,
      password: f_4,
      configuration: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSOpenSessionReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("client_protocol", TType::I32, 1))?;
    self.client_protocol.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("zoneId", TType::String, 2))?;
    o_prot.write_string(&self.zone_id)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.username {
      o_prot.write_field_begin(&TFieldIdentifier::new("username", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.password {
      o_prot.write_field_begin(&TFieldIdentifier::new("password", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.configuration {
      o_prot.write_field_begin(&TFieldIdentifier::new("configuration", TType::Map, 5))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSCloseSessionReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSCloseSessionReq {
  pub session_id: i64,
}

impl TSCloseSessionReq {
  pub fn new(session_id: i64) -> TSCloseSessionReq {
    TSCloseSessionReq {
      session_id,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSCloseSessionReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSCloseSessionReq.session_id", &f_1)?;
    let ret = TSCloseSessionReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSCloseSessionReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSExecuteStatementReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSExecuteStatementReq {
  pub session_id: i64,
  pub statement: String,
  pub statement_id: i64,
  pub fetch_size: Option<i32>,
  pub timeout: Option<i64>,
  pub enable_redirect_query: Option<bool>,
  pub jdbc_query: Option<bool>,
}

impl TSExecuteStatementReq {
  pub fn new<F4, F5, F6, F7>(session_id: i64, statement: String, statement_id: i64, fetch_size: F4, timeout: F5, enable_redirect_query: F6, jdbc_query: F7) -> TSExecuteStatementReq where F4: Into<Option<i32>>, F5: Into<Option<i64>>, F6: Into<Option<bool>>, F7: Into<Option<bool>> {
    TSExecuteStatementReq {
      session_id,
      statement,
      statement_id,
      fetch_size: fetch_size.into(),
      timeout: timeout.into(),
      enable_redirect_query: enable_redirect_query.into(),
      jdbc_query: jdbc_query.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSExecuteStatementReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSExecuteStatementReq.session_id", &f_1)?;
    verify_required_field_exists("TSExecuteStatementReq.statement", &f_2)?;
    verify_required_field_exists("TSExecuteStatementReq.statement_id", &f_3)?;
    let ret = TSExecuteStatementReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      statement: f_2.expect("auto-generated code should have checked for presence of required fields"),
      statement_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      fetch_size: f_4,
      timeout: f_5,
      enable_redirect_query: f_6,
      jdbc_query: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSExecuteStatementReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("statement", TType::String, 2))?;
    o_prot.write_string(&self.statement)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("statementId", TType::I64, 3))?;
    o_prot.write_i64(self.statement_id)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.fetch_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("fetchSize", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.timeout {
      o_prot.write_field_begin(&TFieldIdentifier::new("timeout", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_redirect_query {
      o_prot.write_field_begin(&TFieldIdentifier::new("enableRedirectQuery", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.jdbc_query {
      o_prot.write_field_begin(&TFieldIdentifier::new("jdbcQuery", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSExecuteBatchStatementReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSExecuteBatchStatementReq {
  pub session_id: i64,
  pub statements: Vec<String>,
}

impl TSExecuteBatchStatementReq {
  pub fn new(session_id: i64, statements: Vec<String>) -> TSExecuteBatchStatementReq {
    TSExecuteBatchStatementReq {
      session_id,
      statements,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSExecuteBatchStatementReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_16 = i_prot.read_string()?;
            val.push(list_elem_16);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSExecuteBatchStatementReq.session_id", &f_1)?;
    verify_required_field_exists("TSExecuteBatchStatementReq.statements", &f_2)?;
    let ret = TSExecuteBatchStatementReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      statements: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSExecuteBatchStatementReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("statements", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.statements.len() as i32))?;
    for e in &self.statements {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSGetOperationStatusReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSGetOperationStatusReq {
  pub session_id: i64,
  pub query_id: i64,
}

impl TSGetOperationStatusReq {
  pub fn new(session_id: i64, query_id: i64) -> TSGetOperationStatusReq {
    TSGetOperationStatusReq {
      session_id,
      query_id,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSGetOperationStatusReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSGetOperationStatusReq.session_id", &f_1)?;
    verify_required_field_exists("TSGetOperationStatusReq.query_id", &f_2)?;
    let ret = TSGetOperationStatusReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSGetOperationStatusReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("queryId", TType::I64, 2))?;
    o_prot.write_i64(self.query_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSCancelOperationReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSCancelOperationReq {
  pub session_id: i64,
  pub query_id: i64,
}

impl TSCancelOperationReq {
  pub fn new(session_id: i64, query_id: i64) -> TSCancelOperationReq {
    TSCancelOperationReq {
      session_id,
      query_id,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSCancelOperationReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSCancelOperationReq.session_id", &f_1)?;
    verify_required_field_exists("TSCancelOperationReq.query_id", &f_2)?;
    let ret = TSCancelOperationReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSCancelOperationReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("queryId", TType::I64, 2))?;
    o_prot.write_i64(self.query_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSCloseOperationReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSCloseOperationReq {
  pub session_id: i64,
  pub query_id: Option<i64>,
  pub statement_id: Option<i64>,
}

impl TSCloseOperationReq {
  pub fn new<F2, F3>(session_id: i64, query_id: F2, statement_id: F3) -> TSCloseOperationReq where F2: Into<Option<i64>>, F3: Into<Option<i64>> {
    TSCloseOperationReq {
      session_id,
      query_id: query_id.into(),
      statement_id: statement_id.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSCloseOperationReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSCloseOperationReq.session_id", &f_1)?;
    let ret = TSCloseOperationReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query_id: f_2,
      statement_id: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSCloseOperationReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.query_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryId", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.statement_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("statementId", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSFetchResultsReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSFetchResultsReq {
  pub session_id: i64,
  pub statement: String,
  pub fetch_size: i32,
  pub query_id: i64,
  pub is_align: bool,
  pub timeout: Option<i64>,
}

impl TSFetchResultsReq {
  pub fn new<F6>(session_id: i64, statement: String, fetch_size: i32, query_id: i64, is_align: bool, timeout: F6) -> TSFetchResultsReq where F6: Into<Option<i64>> {
    TSFetchResultsReq {
      session_id,
      statement,
      fetch_size,
      query_id,
      is_align,
      timeout: timeout.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSFetchResultsReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSFetchResultsReq.session_id", &f_1)?;
    verify_required_field_exists("TSFetchResultsReq.statement", &f_2)?;
    verify_required_field_exists("TSFetchResultsReq.fetch_size", &f_3)?;
    verify_required_field_exists("TSFetchResultsReq.query_id", &f_4)?;
    verify_required_field_exists("TSFetchResultsReq.is_align", &f_5)?;
    let ret = TSFetchResultsReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      statement: f_2.expect("auto-generated code should have checked for presence of required fields"),
      fetch_size: f_3.expect("auto-generated code should have checked for presence of required fields"),
      query_id: f_4.expect("auto-generated code should have checked for presence of required fields"),
      is_align: f_5.expect("auto-generated code should have checked for presence of required fields"),
      timeout: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSFetchResultsReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("statement", TType::String, 2))?;
    o_prot.write_string(&self.statement)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fetchSize", TType::I32, 3))?;
    o_prot.write_i32(self.fetch_size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("queryId", TType::I64, 4))?;
    o_prot.write_i64(self.query_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("isAlign", TType::Bool, 5))?;
    o_prot.write_bool(self.is_align)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.timeout {
      o_prot.write_field_begin(&TFieldIdentifier::new("timeout", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSFetchResultsResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSFetchResultsResp {
  pub status: common::TSStatus,
  pub has_result_set: bool,
  pub is_align: bool,
  pub query_data_set: Option<TSQueryDataSet>,
  pub non_align_query_data_set: Option<TSQueryNonAlignDataSet>,
}

impl TSFetchResultsResp {
  pub fn new<F4, F5>(status: common::TSStatus, has_result_set: bool, is_align: bool, query_data_set: F4, non_align_query_data_set: F5) -> TSFetchResultsResp where F4: Into<Option<TSQueryDataSet>>, F5: Into<Option<TSQueryNonAlignDataSet>> {
    TSFetchResultsResp {
      status,
      has_result_set,
      is_align,
      query_data_set: query_data_set.into(),
      non_align_query_data_set: non_align_query_data_set.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSFetchResultsResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<common::TSStatus> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<TSQueryDataSet> = None;
    let mut f_5: Option<TSQueryNonAlignDataSet> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TSQueryDataSet::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = TSQueryNonAlignDataSet::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSFetchResultsResp.status", &f_1)?;
    verify_required_field_exists("TSFetchResultsResp.has_result_set", &f_2)?;
    verify_required_field_exists("TSFetchResultsResp.is_align", &f_3)?;
    let ret = TSFetchResultsResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      has_result_set: f_2.expect("auto-generated code should have checked for presence of required fields"),
      is_align: f_3.expect("auto-generated code should have checked for presence of required fields"),
      query_data_set: f_4,
      non_align_query_data_set: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSFetchResultsResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("hasResultSet", TType::Bool, 2))?;
    o_prot.write_bool(self.has_result_set)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("isAlign", TType::Bool, 3))?;
    o_prot.write_bool(self.is_align)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.query_data_set {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryDataSet", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.non_align_query_data_set {
      o_prot.write_field_begin(&TFieldIdentifier::new("nonAlignQueryDataSet", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSFetchMetadataResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSFetchMetadataResp {
  pub status: common::TSStatus,
  pub metadata_in_json: Option<String>,
  pub columns_list: Option<Vec<String>>,
  pub data_type: Option<String>,
}

impl TSFetchMetadataResp {
  pub fn new<F2, F3, F4>(status: common::TSStatus, metadata_in_json: F2, columns_list: F3, data_type: F4) -> TSFetchMetadataResp where F2: Into<Option<String>>, F3: Into<Option<Vec<String>>>, F4: Into<Option<String>> {
    TSFetchMetadataResp {
      status,
      metadata_in_json: metadata_in_json.into(),
      columns_list: columns_list.into(),
      data_type: data_type.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSFetchMetadataResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<common::TSStatus> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_17 = i_prot.read_string()?;
            val.push(list_elem_17);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSFetchMetadataResp.status", &f_1)?;
    let ret = TSFetchMetadataResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      metadata_in_json: f_2,
      columns_list: f_3,
      data_type: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSFetchMetadataResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.metadata_in_json {
      o_prot.write_field_begin(&TFieldIdentifier::new("metadataInJson", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.columns_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("columnsList", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.data_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("dataType", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSFetchMetadataReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSFetchMetadataReq {
  pub session_id: i64,
  pub type_: String,
  pub column_path: Option<String>,
}

impl TSFetchMetadataReq {
  pub fn new<F3>(session_id: i64, type_: String, column_path: F3) -> TSFetchMetadataReq where F3: Into<Option<String>> {
    TSFetchMetadataReq {
      session_id,
      type_,
      column_path: column_path.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSFetchMetadataReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSFetchMetadataReq.session_id", &f_1)?;
    verify_required_field_exists("TSFetchMetadataReq.type_", &f_2)?;
    let ret = TSFetchMetadataReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      type_: f_2.expect("auto-generated code should have checked for presence of required fields"),
      column_path: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSFetchMetadataReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::String, 2))?;
    o_prot.write_string(&self.type_)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.column_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("columnPath", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSGetTimeZoneResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSGetTimeZoneResp {
  pub status: common::TSStatus,
  pub time_zone: String,
}

impl TSGetTimeZoneResp {
  pub fn new(status: common::TSStatus, time_zone: String) -> TSGetTimeZoneResp {
    TSGetTimeZoneResp {
      status,
      time_zone,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSGetTimeZoneResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<common::TSStatus> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSGetTimeZoneResp.status", &f_1)?;
    verify_required_field_exists("TSGetTimeZoneResp.time_zone", &f_2)?;
    let ret = TSGetTimeZoneResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      time_zone: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSGetTimeZoneResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timeZone", TType::String, 2))?;
    o_prot.write_string(&self.time_zone)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSSetTimeZoneReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSSetTimeZoneReq {
  pub session_id: i64,
  pub time_zone: String,
}

impl TSSetTimeZoneReq {
  pub fn new(session_id: i64, time_zone: String) -> TSSetTimeZoneReq {
    TSSetTimeZoneReq {
      session_id,
      time_zone,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSSetTimeZoneReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSSetTimeZoneReq.session_id", &f_1)?;
    verify_required_field_exists("TSSetTimeZoneReq.time_zone", &f_2)?;
    let ret = TSSetTimeZoneReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      time_zone: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSSetTimeZoneReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timeZone", TType::String, 2))?;
    o_prot.write_string(&self.time_zone)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSInsertRecordReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSInsertRecordReq {
  pub session_id: i64,
  pub prefix_path: String,
  pub measurements: Vec<String>,
  pub values: Vec<u8>,
  pub timestamp: i64,
  pub is_aligned: Option<bool>,
}

impl TSInsertRecordReq {
  pub fn new<F6>(session_id: i64, prefix_path: String, measurements: Vec<String>, values: Vec<u8>, timestamp: i64, is_aligned: F6) -> TSInsertRecordReq where F6: Into<Option<bool>> {
    TSInsertRecordReq {
      session_id,
      prefix_path,
      measurements,
      values,
      timestamp,
      is_aligned: is_aligned.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSInsertRecordReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<u8>> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_18 = i_prot.read_string()?;
            val.push(list_elem_18);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSInsertRecordReq.session_id", &f_1)?;
    verify_required_field_exists("TSInsertRecordReq.prefix_path", &f_2)?;
    verify_required_field_exists("TSInsertRecordReq.measurements", &f_3)?;
    verify_required_field_exists("TSInsertRecordReq.values", &f_4)?;
    verify_required_field_exists("TSInsertRecordReq.timestamp", &f_5)?;
    let ret = TSInsertRecordReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prefix_path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      measurements: f_3.expect("auto-generated code should have checked for presence of required fields"),
      values: f_4.expect("auto-generated code should have checked for presence of required fields"),
      timestamp: f_5.expect("auto-generated code should have checked for presence of required fields"),
      is_aligned: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSInsertRecordReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixPath", TType::String, 2))?;
    o_prot.write_string(&self.prefix_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("measurements", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.measurements.len() as i32))?;
    for e in &self.measurements {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::String, 4))?;
    o_prot.write_bytes(&self.values)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I64, 5))?;
    o_prot.write_i64(self.timestamp)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_aligned {
      o_prot.write_field_begin(&TFieldIdentifier::new("isAligned", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSInsertStringRecordReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSInsertStringRecordReq {
  pub session_id: i64,
  pub prefix_path: String,
  pub measurements: Vec<String>,
  pub values: Vec<String>,
  pub timestamp: i64,
  pub is_aligned: Option<bool>,
  pub timeout: Option<i64>,
}

impl TSInsertStringRecordReq {
  pub fn new<F6, F7>(session_id: i64, prefix_path: String, measurements: Vec<String>, values: Vec<String>, timestamp: i64, is_aligned: F6, timeout: F7) -> TSInsertStringRecordReq where F6: Into<Option<bool>>, F7: Into<Option<i64>> {
    TSInsertStringRecordReq {
      session_id,
      prefix_path,
      measurements,
      values,
      timestamp,
      is_aligned: is_aligned.into(),
      timeout: timeout.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSInsertStringRecordReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<String>> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_19 = i_prot.read_string()?;
            val.push(list_elem_19);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_20 = i_prot.read_string()?;
            val.push(list_elem_20);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSInsertStringRecordReq.session_id", &f_1)?;
    verify_required_field_exists("TSInsertStringRecordReq.prefix_path", &f_2)?;
    verify_required_field_exists("TSInsertStringRecordReq.measurements", &f_3)?;
    verify_required_field_exists("TSInsertStringRecordReq.values", &f_4)?;
    verify_required_field_exists("TSInsertStringRecordReq.timestamp", &f_5)?;
    let ret = TSInsertStringRecordReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prefix_path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      measurements: f_3.expect("auto-generated code should have checked for presence of required fields"),
      values: f_4.expect("auto-generated code should have checked for presence of required fields"),
      timestamp: f_5.expect("auto-generated code should have checked for presence of required fields"),
      is_aligned: f_6,
      timeout: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSInsertStringRecordReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixPath", TType::String, 2))?;
    o_prot.write_string(&self.prefix_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("measurements", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.measurements.len() as i32))?;
    for e in &self.measurements {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.values.len() as i32))?;
    for e in &self.values {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I64, 5))?;
    o_prot.write_i64(self.timestamp)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_aligned {
      o_prot.write_field_begin(&TFieldIdentifier::new("isAligned", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.timeout {
      o_prot.write_field_begin(&TFieldIdentifier::new("timeout", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSInsertTabletReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSInsertTabletReq {
  pub session_id: i64,
  pub prefix_path: String,
  pub measurements: Vec<String>,
  pub values: Vec<u8>,
  pub timestamps: Vec<u8>,
  pub types: Vec<i32>,
  pub size: i32,
  pub is_aligned: Option<bool>,
}

impl TSInsertTabletReq {
  pub fn new<F8>(session_id: i64, prefix_path: String, measurements: Vec<String>, values: Vec<u8>, timestamps: Vec<u8>, types: Vec<i32>, size: i32, is_aligned: F8) -> TSInsertTabletReq where F8: Into<Option<bool>> {
    TSInsertTabletReq {
      session_id,
      prefix_path,
      measurements,
      values,
      timestamps,
      types,
      size,
      is_aligned: is_aligned.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSInsertTabletReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<u8>> = None;
    let mut f_5: Option<Vec<u8>> = None;
    let mut f_6: Option<Vec<i32>> = None;
    let mut f_7: Option<i32> = None;
    let mut f_8: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_21 = i_prot.read_string()?;
            val.push(list_elem_21);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_22 = i_prot.read_i32()?;
            val.push(list_elem_22);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSInsertTabletReq.session_id", &f_1)?;
    verify_required_field_exists("TSInsertTabletReq.prefix_path", &f_2)?;
    verify_required_field_exists("TSInsertTabletReq.measurements", &f_3)?;
    verify_required_field_exists("TSInsertTabletReq.values", &f_4)?;
    verify_required_field_exists("TSInsertTabletReq.timestamps", &f_5)?;
    verify_required_field_exists("TSInsertTabletReq.types", &f_6)?;
    verify_required_field_exists("TSInsertTabletReq.size", &f_7)?;
    let ret = TSInsertTabletReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prefix_path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      measurements: f_3.expect("auto-generated code should have checked for presence of required fields"),
      values: f_4.expect("auto-generated code should have checked for presence of required fields"),
      timestamps: f_5.expect("auto-generated code should have checked for presence of required fields"),
      types: f_6.expect("auto-generated code should have checked for presence of required fields"),
      size: f_7.expect("auto-generated code should have checked for presence of required fields"),
      is_aligned: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSInsertTabletReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixPath", TType::String, 2))?;
    o_prot.write_string(&self.prefix_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("measurements", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.measurements.len() as i32))?;
    for e in &self.measurements {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::String, 4))?;
    o_prot.write_bytes(&self.values)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamps", TType::String, 5))?;
    o_prot.write_bytes(&self.timestamps)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("types", TType::List, 6))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.types.len() as i32))?;
    for e in &self.types {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("size", TType::I32, 7))?;
    o_prot.write_i32(self.size)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_aligned {
      o_prot.write_field_begin(&TFieldIdentifier::new("isAligned", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSInsertTabletsReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSInsertTabletsReq {
  pub session_id: i64,
  pub prefix_paths: Vec<String>,
  pub measurements_list: Vec<Vec<String>>,
  pub values_list: Vec<Vec<u8>>,
  pub timestamps_list: Vec<Vec<u8>>,
  pub types_list: Vec<Vec<i32>>,
  pub size_list: Vec<i32>,
  pub is_aligned: Option<bool>,
}

impl TSInsertTabletsReq {
  pub fn new<F8>(session_id: i64, prefix_paths: Vec<String>, measurements_list: Vec<Vec<String>>, values_list: Vec<Vec<u8>>, timestamps_list: Vec<Vec<u8>>, types_list: Vec<Vec<i32>>, size_list: Vec<i32>, is_aligned: F8) -> TSInsertTabletsReq where F8: Into<Option<bool>> {
    TSInsertTabletsReq {
      session_id,
      prefix_paths,
      measurements_list,
      values_list,
      timestamps_list,
      types_list,
      size_list,
      is_aligned: is_aligned.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSInsertTabletsReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<Vec<Vec<String>>> = None;
    let mut f_4: Option<Vec<Vec<u8>>> = None;
    let mut f_5: Option<Vec<Vec<u8>>> = None;
    let mut f_6: Option<Vec<Vec<i32>>> = None;
    let mut f_7: Option<Vec<i32>> = None;
    let mut f_8: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_23 = i_prot.read_string()?;
            val.push(list_elem_23);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_24: Vec<String> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_25 = i_prot.read_string()?;
              list_elem_24.push(list_elem_25);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_24);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_26 = i_prot.read_bytes()?;
            val.push(list_elem_26);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_27 = i_prot.read_bytes()?;
            val.push(list_elem_27);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<i32>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_28: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_29 = i_prot.read_i32()?;
              list_elem_28.push(list_elem_29);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_28);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_30 = i_prot.read_i32()?;
            val.push(list_elem_30);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSInsertTabletsReq.session_id", &f_1)?;
    verify_required_field_exists("TSInsertTabletsReq.prefix_paths", &f_2)?;
    verify_required_field_exists("TSInsertTabletsReq.measurements_list", &f_3)?;
    verify_required_field_exists("TSInsertTabletsReq.values_list", &f_4)?;
    verify_required_field_exists("TSInsertTabletsReq.timestamps_list", &f_5)?;
    verify_required_field_exists("TSInsertTabletsReq.types_list", &f_6)?;
    verify_required_field_exists("TSInsertTabletsReq.size_list", &f_7)?;
    let ret = TSInsertTabletsReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prefix_paths: f_2.expect("auto-generated code should have checked for presence of required fields"),
      measurements_list: f_3.expect("auto-generated code should have checked for presence of required fields"),
      values_list: f_4.expect("auto-generated code should have checked for presence of required fields"),
      timestamps_list: f_5.expect("auto-generated code should have checked for presence of required fields"),
      types_list: f_6.expect("auto-generated code should have checked for presence of required fields"),
      size_list: f_7.expect("auto-generated code should have checked for presence of required fields"),
      is_aligned: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSInsertTabletsReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixPaths", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.prefix_paths.len() as i32))?;
    for e in &self.prefix_paths {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("measurementsList", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.measurements_list.len() as i32))?;
    for e in &self.measurements_list {
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, e.len() as i32))?;
      for e in e {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("valuesList", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.values_list.len() as i32))?;
    for e in &self.values_list {
      o_prot.write_bytes(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestampsList", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.timestamps_list.len() as i32))?;
    for e in &self.timestamps_list {
      o_prot.write_bytes(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("typesList", TType::List, 6))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.types_list.len() as i32))?;
    for e in &self.types_list {
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, e.len() as i32))?;
      for e in e {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sizeList", TType::List, 7))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.size_list.len() as i32))?;
    for e in &self.size_list {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_aligned {
      o_prot.write_field_begin(&TFieldIdentifier::new("isAligned", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSInsertRecordsReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSInsertRecordsReq {
  pub session_id: i64,
  pub prefix_paths: Vec<String>,
  pub measurements_list: Vec<Vec<String>>,
  pub values_list: Vec<Vec<u8>>,
  pub timestamps: Vec<i64>,
  pub is_aligned: Option<bool>,
}

impl TSInsertRecordsReq {
  pub fn new<F6>(session_id: i64, prefix_paths: Vec<String>, measurements_list: Vec<Vec<String>>, values_list: Vec<Vec<u8>>, timestamps: Vec<i64>, is_aligned: F6) -> TSInsertRecordsReq where F6: Into<Option<bool>> {
    TSInsertRecordsReq {
      session_id,
      prefix_paths,
      measurements_list,
      values_list,
      timestamps,
      is_aligned: is_aligned.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSInsertRecordsReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<Vec<Vec<String>>> = None;
    let mut f_4: Option<Vec<Vec<u8>>> = None;
    let mut f_5: Option<Vec<i64>> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_31 = i_prot.read_string()?;
            val.push(list_elem_31);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_32: Vec<String> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_33 = i_prot.read_string()?;
              list_elem_32.push(list_elem_33);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_32);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_34 = i_prot.read_bytes()?;
            val.push(list_elem_34);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_35 = i_prot.read_i64()?;
            val.push(list_elem_35);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSInsertRecordsReq.session_id", &f_1)?;
    verify_required_field_exists("TSInsertRecordsReq.prefix_paths", &f_2)?;
    verify_required_field_exists("TSInsertRecordsReq.measurements_list", &f_3)?;
    verify_required_field_exists("TSInsertRecordsReq.values_list", &f_4)?;
    verify_required_field_exists("TSInsertRecordsReq.timestamps", &f_5)?;
    let ret = TSInsertRecordsReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prefix_paths: f_2.expect("auto-generated code should have checked for presence of required fields"),
      measurements_list: f_3.expect("auto-generated code should have checked for presence of required fields"),
      values_list: f_4.expect("auto-generated code should have checked for presence of required fields"),
      timestamps: f_5.expect("auto-generated code should have checked for presence of required fields"),
      is_aligned: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSInsertRecordsReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixPaths", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.prefix_paths.len() as i32))?;
    for e in &self.prefix_paths {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("measurementsList", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.measurements_list.len() as i32))?;
    for e in &self.measurements_list {
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, e.len() as i32))?;
      for e in e {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("valuesList", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.values_list.len() as i32))?;
    for e in &self.values_list {
      o_prot.write_bytes(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamps", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.timestamps.len() as i32))?;
    for e in &self.timestamps {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_aligned {
      o_prot.write_field_begin(&TFieldIdentifier::new("isAligned", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSInsertRecordsOfOneDeviceReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSInsertRecordsOfOneDeviceReq {
  pub session_id: i64,
  pub prefix_path: String,
  pub measurements_list: Vec<Vec<String>>,
  pub values_list: Vec<Vec<u8>>,
  pub timestamps: Vec<i64>,
  pub is_aligned: Option<bool>,
}

impl TSInsertRecordsOfOneDeviceReq {
  pub fn new<F6>(session_id: i64, prefix_path: String, measurements_list: Vec<Vec<String>>, values_list: Vec<Vec<u8>>, timestamps: Vec<i64>, is_aligned: F6) -> TSInsertRecordsOfOneDeviceReq where F6: Into<Option<bool>> {
    TSInsertRecordsOfOneDeviceReq {
      session_id,
      prefix_path,
      measurements_list,
      values_list,
      timestamps,
      is_aligned: is_aligned.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSInsertRecordsOfOneDeviceReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<Vec<String>>> = None;
    let mut f_4: Option<Vec<Vec<u8>>> = None;
    let mut f_5: Option<Vec<i64>> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_36: Vec<String> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_37 = i_prot.read_string()?;
              list_elem_36.push(list_elem_37);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_36);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_38 = i_prot.read_bytes()?;
            val.push(list_elem_38);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_39 = i_prot.read_i64()?;
            val.push(list_elem_39);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSInsertRecordsOfOneDeviceReq.session_id", &f_1)?;
    verify_required_field_exists("TSInsertRecordsOfOneDeviceReq.prefix_path", &f_2)?;
    verify_required_field_exists("TSInsertRecordsOfOneDeviceReq.measurements_list", &f_3)?;
    verify_required_field_exists("TSInsertRecordsOfOneDeviceReq.values_list", &f_4)?;
    verify_required_field_exists("TSInsertRecordsOfOneDeviceReq.timestamps", &f_5)?;
    let ret = TSInsertRecordsOfOneDeviceReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prefix_path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      measurements_list: f_3.expect("auto-generated code should have checked for presence of required fields"),
      values_list: f_4.expect("auto-generated code should have checked for presence of required fields"),
      timestamps: f_5.expect("auto-generated code should have checked for presence of required fields"),
      is_aligned: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSInsertRecordsOfOneDeviceReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixPath", TType::String, 2))?;
    o_prot.write_string(&self.prefix_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("measurementsList", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.measurements_list.len() as i32))?;
    for e in &self.measurements_list {
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, e.len() as i32))?;
      for e in e {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("valuesList", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.values_list.len() as i32))?;
    for e in &self.values_list {
      o_prot.write_bytes(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamps", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.timestamps.len() as i32))?;
    for e in &self.timestamps {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_aligned {
      o_prot.write_field_begin(&TFieldIdentifier::new("isAligned", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSInsertStringRecordsOfOneDeviceReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSInsertStringRecordsOfOneDeviceReq {
  pub session_id: i64,
  pub prefix_path: String,
  pub measurements_list: Vec<Vec<String>>,
  pub values_list: Vec<Vec<String>>,
  pub timestamps: Vec<i64>,
  pub is_aligned: Option<bool>,
}

impl TSInsertStringRecordsOfOneDeviceReq {
  pub fn new<F6>(session_id: i64, prefix_path: String, measurements_list: Vec<Vec<String>>, values_list: Vec<Vec<String>>, timestamps: Vec<i64>, is_aligned: F6) -> TSInsertStringRecordsOfOneDeviceReq where F6: Into<Option<bool>> {
    TSInsertStringRecordsOfOneDeviceReq {
      session_id,
      prefix_path,
      measurements_list,
      values_list,
      timestamps,
      is_aligned: is_aligned.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSInsertStringRecordsOfOneDeviceReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<Vec<String>>> = None;
    let mut f_4: Option<Vec<Vec<String>>> = None;
    let mut f_5: Option<Vec<i64>> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_40: Vec<String> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_41 = i_prot.read_string()?;
              list_elem_40.push(list_elem_41);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_40);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_42: Vec<String> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_43 = i_prot.read_string()?;
              list_elem_42.push(list_elem_43);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_42);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_44 = i_prot.read_i64()?;
            val.push(list_elem_44);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSInsertStringRecordsOfOneDeviceReq.session_id", &f_1)?;
    verify_required_field_exists("TSInsertStringRecordsOfOneDeviceReq.prefix_path", &f_2)?;
    verify_required_field_exists("TSInsertStringRecordsOfOneDeviceReq.measurements_list", &f_3)?;
    verify_required_field_exists("TSInsertStringRecordsOfOneDeviceReq.values_list", &f_4)?;
    verify_required_field_exists("TSInsertStringRecordsOfOneDeviceReq.timestamps", &f_5)?;
    let ret = TSInsertStringRecordsOfOneDeviceReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prefix_path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      measurements_list: f_3.expect("auto-generated code should have checked for presence of required fields"),
      values_list: f_4.expect("auto-generated code should have checked for presence of required fields"),
      timestamps: f_5.expect("auto-generated code should have checked for presence of required fields"),
      is_aligned: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSInsertStringRecordsOfOneDeviceReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixPath", TType::String, 2))?;
    o_prot.write_string(&self.prefix_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("measurementsList", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.measurements_list.len() as i32))?;
    for e in &self.measurements_list {
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, e.len() as i32))?;
      for e in e {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("valuesList", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.values_list.len() as i32))?;
    for e in &self.values_list {
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, e.len() as i32))?;
      for e in e {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamps", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.timestamps.len() as i32))?;
    for e in &self.timestamps {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_aligned {
      o_prot.write_field_begin(&TFieldIdentifier::new("isAligned", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSInsertStringRecordsReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSInsertStringRecordsReq {
  pub session_id: i64,
  pub prefix_paths: Vec<String>,
  pub measurements_list: Vec<Vec<String>>,
  pub values_list: Vec<Vec<String>>,
  pub timestamps: Vec<i64>,
  pub is_aligned: Option<bool>,
}

impl TSInsertStringRecordsReq {
  pub fn new<F6>(session_id: i64, prefix_paths: Vec<String>, measurements_list: Vec<Vec<String>>, values_list: Vec<Vec<String>>, timestamps: Vec<i64>, is_aligned: F6) -> TSInsertStringRecordsReq where F6: Into<Option<bool>> {
    TSInsertStringRecordsReq {
      session_id,
      prefix_paths,
      measurements_list,
      values_list,
      timestamps,
      is_aligned: is_aligned.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSInsertStringRecordsReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<Vec<Vec<String>>> = None;
    let mut f_4: Option<Vec<Vec<String>>> = None;
    let mut f_5: Option<Vec<i64>> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_45 = i_prot.read_string()?;
            val.push(list_elem_45);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_46: Vec<String> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_47 = i_prot.read_string()?;
              list_elem_46.push(list_elem_47);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_46);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_48: Vec<String> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_49 = i_prot.read_string()?;
              list_elem_48.push(list_elem_49);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_48);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_50 = i_prot.read_i64()?;
            val.push(list_elem_50);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSInsertStringRecordsReq.session_id", &f_1)?;
    verify_required_field_exists("TSInsertStringRecordsReq.prefix_paths", &f_2)?;
    verify_required_field_exists("TSInsertStringRecordsReq.measurements_list", &f_3)?;
    verify_required_field_exists("TSInsertStringRecordsReq.values_list", &f_4)?;
    verify_required_field_exists("TSInsertStringRecordsReq.timestamps", &f_5)?;
    let ret = TSInsertStringRecordsReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prefix_paths: f_2.expect("auto-generated code should have checked for presence of required fields"),
      measurements_list: f_3.expect("auto-generated code should have checked for presence of required fields"),
      values_list: f_4.expect("auto-generated code should have checked for presence of required fields"),
      timestamps: f_5.expect("auto-generated code should have checked for presence of required fields"),
      is_aligned: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSInsertStringRecordsReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixPaths", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.prefix_paths.len() as i32))?;
    for e in &self.prefix_paths {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("measurementsList", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.measurements_list.len() as i32))?;
    for e in &self.measurements_list {
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, e.len() as i32))?;
      for e in e {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("valuesList", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.values_list.len() as i32))?;
    for e in &self.values_list {
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, e.len() as i32))?;
      for e in e {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamps", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.timestamps.len() as i32))?;
    for e in &self.timestamps {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_aligned {
      o_prot.write_field_begin(&TFieldIdentifier::new("isAligned", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSDeleteDataReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSDeleteDataReq {
  pub session_id: i64,
  pub paths: Vec<String>,
  pub start_time: i64,
  pub end_time: i64,
}

impl TSDeleteDataReq {
  pub fn new(session_id: i64, paths: Vec<String>, start_time: i64, end_time: i64) -> TSDeleteDataReq {
    TSDeleteDataReq {
      session_id,
      paths,
      start_time,
      end_time,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSDeleteDataReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_51 = i_prot.read_string()?;
            val.push(list_elem_51);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSDeleteDataReq.session_id", &f_1)?;
    verify_required_field_exists("TSDeleteDataReq.paths", &f_2)?;
    verify_required_field_exists("TSDeleteDataReq.start_time", &f_3)?;
    verify_required_field_exists("TSDeleteDataReq.end_time", &f_4)?;
    let ret = TSDeleteDataReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      paths: f_2.expect("auto-generated code should have checked for presence of required fields"),
      start_time: f_3.expect("auto-generated code should have checked for presence of required fields"),
      end_time: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSDeleteDataReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("paths", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.paths.len() as i32))?;
    for e in &self.paths {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("startTime", TType::I64, 3))?;
    o_prot.write_i64(self.start_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("endTime", TType::I64, 4))?;
    o_prot.write_i64(self.end_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSCreateTimeseriesReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSCreateTimeseriesReq {
  pub session_id: i64,
  pub path: String,
  pub data_type: i32,
  pub encoding: i32,
  pub compressor: i32,
  pub props: Option<BTreeMap<String, String>>,
  pub tags: Option<BTreeMap<String, String>>,
  pub attributes: Option<BTreeMap<String, String>>,
  pub measurement_alias: Option<String>,
}

impl TSCreateTimeseriesReq {
  pub fn new<F6, F7, F8, F9>(session_id: i64, path: String, data_type: i32, encoding: i32, compressor: i32, props: F6, tags: F7, attributes: F8, measurement_alias: F9) -> TSCreateTimeseriesReq where F6: Into<Option<BTreeMap<String, String>>>, F7: Into<Option<BTreeMap<String, String>>>, F8: Into<Option<BTreeMap<String, String>>>, F9: Into<Option<String>> {
    TSCreateTimeseriesReq {
      session_id,
      path,
      data_type,
      encoding,
      compressor,
      props: props.into(),
      tags: tags.into(),
      attributes: attributes.into(),
      measurement_alias: measurement_alias.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSCreateTimeseriesReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<BTreeMap<String, String>> = None;
    let mut f_7: Option<BTreeMap<String, String>> = None;
    let mut f_8: Option<BTreeMap<String, String>> = None;
    let mut f_9: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_52 = i_prot.read_string()?;
            let map_val_53 = i_prot.read_string()?;
            val.insert(map_key_52, map_val_53);
          }
          i_prot.read_map_end()?;
          f_6 = Some(val);
        },
        7 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_54 = i_prot.read_string()?;
            let map_val_55 = i_prot.read_string()?;
            val.insert(map_key_54, map_val_55);
          }
          i_prot.read_map_end()?;
          f_7 = Some(val);
        },
        8 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_56 = i_prot.read_string()?;
            let map_val_57 = i_prot.read_string()?;
            val.insert(map_key_56, map_val_57);
          }
          i_prot.read_map_end()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSCreateTimeseriesReq.session_id", &f_1)?;
    verify_required_field_exists("TSCreateTimeseriesReq.path", &f_2)?;
    verify_required_field_exists("TSCreateTimeseriesReq.data_type", &f_3)?;
    verify_required_field_exists("TSCreateTimeseriesReq.encoding", &f_4)?;
    verify_required_field_exists("TSCreateTimeseriesReq.compressor", &f_5)?;
    let ret = TSCreateTimeseriesReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      data_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
      encoding: f_4.expect("auto-generated code should have checked for presence of required fields"),
      compressor: f_5.expect("auto-generated code should have checked for presence of required fields"),
      props: f_6,
      tags: f_7,
      attributes: f_8,
      measurement_alias: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSCreateTimeseriesReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("path", TType::String, 2))?;
    o_prot.write_string(&self.path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dataType", TType::I32, 3))?;
    o_prot.write_i32(self.data_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encoding", TType::I32, 4))?;
    o_prot.write_i32(self.encoding)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("compressor", TType::I32, 5))?;
    o_prot.write_i32(self.compressor)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.props {
      o_prot.write_field_begin(&TFieldIdentifier::new("props", TType::Map, 6))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tags {
      o_prot.write_field_begin(&TFieldIdentifier::new("tags", TType::Map, 7))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("attributes", TType::Map, 8))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.measurement_alias {
      o_prot.write_field_begin(&TFieldIdentifier::new("measurementAlias", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSCreateAlignedTimeseriesReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSCreateAlignedTimeseriesReq {
  pub session_id: i64,
  pub prefix_path: String,
  pub measurements: Vec<String>,
  pub data_types: Vec<i32>,
  pub encodings: Vec<i32>,
  pub compressors: Vec<i32>,
  pub measurement_alias: Option<Vec<String>>,
  pub tags_list: Option<Vec<BTreeMap<String, String>>>,
  pub attributes_list: Option<Vec<BTreeMap<String, String>>>,
}

impl TSCreateAlignedTimeseriesReq {
  pub fn new<F7, F8, F9>(session_id: i64, prefix_path: String, measurements: Vec<String>, data_types: Vec<i32>, encodings: Vec<i32>, compressors: Vec<i32>, measurement_alias: F7, tags_list: F8, attributes_list: F9) -> TSCreateAlignedTimeseriesReq where F7: Into<Option<Vec<String>>>, F8: Into<Option<Vec<BTreeMap<String, String>>>>, F9: Into<Option<Vec<BTreeMap<String, String>>>> {
    TSCreateAlignedTimeseriesReq {
      session_id,
      prefix_path,
      measurements,
      data_types,
      encodings,
      compressors,
      measurement_alias: measurement_alias.into(),
      tags_list: tags_list.into(),
      attributes_list: attributes_list.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSCreateAlignedTimeseriesReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<i32>> = None;
    let mut f_5: Option<Vec<i32>> = None;
    let mut f_6: Option<Vec<i32>> = None;
    let mut f_7: Option<Vec<String>> = None;
    let mut f_8: Option<Vec<BTreeMap<String, String>>> = None;
    let mut f_9: Option<Vec<BTreeMap<String, String>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_58 = i_prot.read_string()?;
            val.push(list_elem_58);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_59 = i_prot.read_i32()?;
            val.push(list_elem_59);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_60 = i_prot.read_i32()?;
            val.push(list_elem_60);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_61 = i_prot.read_i32()?;
            val.push(list_elem_61);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_62 = i_prot.read_string()?;
            val.push(list_elem_62);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<BTreeMap<String, String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let map_ident = i_prot.read_map_begin()?;
            let mut list_elem_63: BTreeMap<String, String> = BTreeMap::new();
            for _ in 0..map_ident.size {
              let map_key_64 = i_prot.read_string()?;
              let map_val_65 = i_prot.read_string()?;
              list_elem_63.insert(map_key_64, map_val_65);
            }
            i_prot.read_map_end()?;
            val.push(list_elem_63);
          }
          i_prot.read_list_end()?;
          f_8 = Some(val);
        },
        9 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<BTreeMap<String, String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let map_ident = i_prot.read_map_begin()?;
            let mut list_elem_66: BTreeMap<String, String> = BTreeMap::new();
            for _ in 0..map_ident.size {
              let map_key_67 = i_prot.read_string()?;
              let map_val_68 = i_prot.read_string()?;
              list_elem_66.insert(map_key_67, map_val_68);
            }
            i_prot.read_map_end()?;
            val.push(list_elem_66);
          }
          i_prot.read_list_end()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSCreateAlignedTimeseriesReq.session_id", &f_1)?;
    verify_required_field_exists("TSCreateAlignedTimeseriesReq.prefix_path", &f_2)?;
    verify_required_field_exists("TSCreateAlignedTimeseriesReq.measurements", &f_3)?;
    verify_required_field_exists("TSCreateAlignedTimeseriesReq.data_types", &f_4)?;
    verify_required_field_exists("TSCreateAlignedTimeseriesReq.encodings", &f_5)?;
    verify_required_field_exists("TSCreateAlignedTimeseriesReq.compressors", &f_6)?;
    let ret = TSCreateAlignedTimeseriesReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prefix_path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      measurements: f_3.expect("auto-generated code should have checked for presence of required fields"),
      data_types: f_4.expect("auto-generated code should have checked for presence of required fields"),
      encodings: f_5.expect("auto-generated code should have checked for presence of required fields"),
      compressors: f_6.expect("auto-generated code should have checked for presence of required fields"),
      measurement_alias: f_7,
      tags_list: f_8,
      attributes_list: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSCreateAlignedTimeseriesReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixPath", TType::String, 2))?;
    o_prot.write_string(&self.prefix_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("measurements", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.measurements.len() as i32))?;
    for e in &self.measurements {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dataTypes", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.data_types.len() as i32))?;
    for e in &self.data_types {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encodings", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.encodings.len() as i32))?;
    for e in &self.encodings {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("compressors", TType::List, 6))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.compressors.len() as i32))?;
    for e in &self.compressors {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.measurement_alias {
      o_prot.write_field_begin(&TFieldIdentifier::new("measurementAlias", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tags_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("tagsList", TType::List, 8))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Map, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, e.len() as i32))?;
        for (k, v) in e {
          o_prot.write_string(k)?;
          o_prot.write_string(v)?;
        }
        o_prot.write_map_end()?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.attributes_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("attributesList", TType::List, 9))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Map, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, e.len() as i32))?;
        for (k, v) in e {
          o_prot.write_string(k)?;
          o_prot.write_string(v)?;
        }
        o_prot.write_map_end()?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSRawDataQueryReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSRawDataQueryReq {
  pub session_id: i64,
  pub paths: Vec<String>,
  pub fetch_size: Option<i32>,
  pub start_time: i64,
  pub end_time: i64,
  pub statement_id: i64,
  pub enable_redirect_query: Option<bool>,
  pub jdbc_query: Option<bool>,
  pub timeout: Option<i64>,
}

impl TSRawDataQueryReq {
  pub fn new<F3, F7, F8, F9>(session_id: i64, paths: Vec<String>, fetch_size: F3, start_time: i64, end_time: i64, statement_id: i64, enable_redirect_query: F7, jdbc_query: F8, timeout: F9) -> TSRawDataQueryReq where F3: Into<Option<i32>>, F7: Into<Option<bool>>, F8: Into<Option<bool>>, F9: Into<Option<i64>> {
    TSRawDataQueryReq {
      session_id,
      paths,
      fetch_size: fetch_size.into(),
      start_time,
      end_time,
      statement_id,
      enable_redirect_query: enable_redirect_query.into(),
      jdbc_query: jdbc_query.into(),
      timeout: timeout.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSRawDataQueryReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<i64> = None;
    let mut f_7: Option<bool> = None;
    let mut f_8: Option<bool> = None;
    let mut f_9: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_69 = i_prot.read_string()?;
            val.push(list_elem_69);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i64()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSRawDataQueryReq.session_id", &f_1)?;
    verify_required_field_exists("TSRawDataQueryReq.paths", &f_2)?;
    verify_required_field_exists("TSRawDataQueryReq.start_time", &f_4)?;
    verify_required_field_exists("TSRawDataQueryReq.end_time", &f_5)?;
    verify_required_field_exists("TSRawDataQueryReq.statement_id", &f_6)?;
    let ret = TSRawDataQueryReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      paths: f_2.expect("auto-generated code should have checked for presence of required fields"),
      fetch_size: f_3,
      start_time: f_4.expect("auto-generated code should have checked for presence of required fields"),
      end_time: f_5.expect("auto-generated code should have checked for presence of required fields"),
      statement_id: f_6.expect("auto-generated code should have checked for presence of required fields"),
      enable_redirect_query: f_7,
      jdbc_query: f_8,
      timeout: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSRawDataQueryReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("paths", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.paths.len() as i32))?;
    for e in &self.paths {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.fetch_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("fetchSize", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("startTime", TType::I64, 4))?;
    o_prot.write_i64(self.start_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("endTime", TType::I64, 5))?;
    o_prot.write_i64(self.end_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("statementId", TType::I64, 6))?;
    o_prot.write_i64(self.statement_id)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.enable_redirect_query {
      o_prot.write_field_begin(&TFieldIdentifier::new("enableRedirectQuery", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.jdbc_query {
      o_prot.write_field_begin(&TFieldIdentifier::new("jdbcQuery", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.timeout {
      o_prot.write_field_begin(&TFieldIdentifier::new("timeout", TType::I64, 9))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSLastDataQueryReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSLastDataQueryReq {
  pub session_id: i64,
  pub paths: Vec<String>,
  pub fetch_size: Option<i32>,
  pub time: i64,
  pub statement_id: i64,
  pub enable_redirect_query: Option<bool>,
  pub jdbc_query: Option<bool>,
  pub timeout: Option<i64>,
}

impl TSLastDataQueryReq {
  pub fn new<F3, F6, F7, F8>(session_id: i64, paths: Vec<String>, fetch_size: F3, time: i64, statement_id: i64, enable_redirect_query: F6, jdbc_query: F7, timeout: F8) -> TSLastDataQueryReq where F3: Into<Option<i32>>, F6: Into<Option<bool>>, F7: Into<Option<bool>>, F8: Into<Option<i64>> {
    TSLastDataQueryReq {
      session_id,
      paths,
      fetch_size: fetch_size.into(),
      time,
      statement_id,
      enable_redirect_query: enable_redirect_query.into(),
      jdbc_query: jdbc_query.into(),
      timeout: timeout.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSLastDataQueryReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<bool> = None;
    let mut f_8: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_70 = i_prot.read_string()?;
            val.push(list_elem_70);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSLastDataQueryReq.session_id", &f_1)?;
    verify_required_field_exists("TSLastDataQueryReq.paths", &f_2)?;
    verify_required_field_exists("TSLastDataQueryReq.time", &f_4)?;
    verify_required_field_exists("TSLastDataQueryReq.statement_id", &f_5)?;
    let ret = TSLastDataQueryReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      paths: f_2.expect("auto-generated code should have checked for presence of required fields"),
      fetch_size: f_3,
      time: f_4.expect("auto-generated code should have checked for presence of required fields"),
      statement_id: f_5.expect("auto-generated code should have checked for presence of required fields"),
      enable_redirect_query: f_6,
      jdbc_query: f_7,
      timeout: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSLastDataQueryReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("paths", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.paths.len() as i32))?;
    for e in &self.paths {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.fetch_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("fetchSize", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("time", TType::I64, 4))?;
    o_prot.write_i64(self.time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("statementId", TType::I64, 5))?;
    o_prot.write_i64(self.statement_id)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.enable_redirect_query {
      o_prot.write_field_begin(&TFieldIdentifier::new("enableRedirectQuery", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.jdbc_query {
      o_prot.write_field_begin(&TFieldIdentifier::new("jdbcQuery", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.timeout {
      o_prot.write_field_begin(&TFieldIdentifier::new("timeout", TType::I64, 8))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSCreateMultiTimeseriesReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSCreateMultiTimeseriesReq {
  pub session_id: i64,
  pub paths: Vec<String>,
  pub data_types: Vec<i32>,
  pub encodings: Vec<i32>,
  pub compressors: Vec<i32>,
  pub props_list: Option<Vec<BTreeMap<String, String>>>,
  pub tags_list: Option<Vec<BTreeMap<String, String>>>,
  pub attributes_list: Option<Vec<BTreeMap<String, String>>>,
  pub measurement_alias_list: Option<Vec<String>>,
}

impl TSCreateMultiTimeseriesReq {
  pub fn new<F6, F7, F8, F9>(session_id: i64, paths: Vec<String>, data_types: Vec<i32>, encodings: Vec<i32>, compressors: Vec<i32>, props_list: F6, tags_list: F7, attributes_list: F8, measurement_alias_list: F9) -> TSCreateMultiTimeseriesReq where F6: Into<Option<Vec<BTreeMap<String, String>>>>, F7: Into<Option<Vec<BTreeMap<String, String>>>>, F8: Into<Option<Vec<BTreeMap<String, String>>>>, F9: Into<Option<Vec<String>>> {
    TSCreateMultiTimeseriesReq {
      session_id,
      paths,
      data_types,
      encodings,
      compressors,
      props_list: props_list.into(),
      tags_list: tags_list.into(),
      attributes_list: attributes_list.into(),
      measurement_alias_list: measurement_alias_list.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSCreateMultiTimeseriesReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<Vec<i32>> = None;
    let mut f_4: Option<Vec<i32>> = None;
    let mut f_5: Option<Vec<i32>> = None;
    let mut f_6: Option<Vec<BTreeMap<String, String>>> = None;
    let mut f_7: Option<Vec<BTreeMap<String, String>>> = None;
    let mut f_8: Option<Vec<BTreeMap<String, String>>> = None;
    let mut f_9: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_71 = i_prot.read_string()?;
            val.push(list_elem_71);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_72 = i_prot.read_i32()?;
            val.push(list_elem_72);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_73 = i_prot.read_i32()?;
            val.push(list_elem_73);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_74 = i_prot.read_i32()?;
            val.push(list_elem_74);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<BTreeMap<String, String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let map_ident = i_prot.read_map_begin()?;
            let mut list_elem_75: BTreeMap<String, String> = BTreeMap::new();
            for _ in 0..map_ident.size {
              let map_key_76 = i_prot.read_string()?;
              let map_val_77 = i_prot.read_string()?;
              list_elem_75.insert(map_key_76, map_val_77);
            }
            i_prot.read_map_end()?;
            val.push(list_elem_75);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<BTreeMap<String, String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let map_ident = i_prot.read_map_begin()?;
            let mut list_elem_78: BTreeMap<String, String> = BTreeMap::new();
            for _ in 0..map_ident.size {
              let map_key_79 = i_prot.read_string()?;
              let map_val_80 = i_prot.read_string()?;
              list_elem_78.insert(map_key_79, map_val_80);
            }
            i_prot.read_map_end()?;
            val.push(list_elem_78);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<BTreeMap<String, String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let map_ident = i_prot.read_map_begin()?;
            let mut list_elem_81: BTreeMap<String, String> = BTreeMap::new();
            for _ in 0..map_ident.size {
              let map_key_82 = i_prot.read_string()?;
              let map_val_83 = i_prot.read_string()?;
              list_elem_81.insert(map_key_82, map_val_83);
            }
            i_prot.read_map_end()?;
            val.push(list_elem_81);
          }
          i_prot.read_list_end()?;
          f_8 = Some(val);
        },
        9 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_84 = i_prot.read_string()?;
            val.push(list_elem_84);
          }
          i_prot.read_list_end()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSCreateMultiTimeseriesReq.session_id", &f_1)?;
    verify_required_field_exists("TSCreateMultiTimeseriesReq.paths", &f_2)?;
    verify_required_field_exists("TSCreateMultiTimeseriesReq.data_types", &f_3)?;
    verify_required_field_exists("TSCreateMultiTimeseriesReq.encodings", &f_4)?;
    verify_required_field_exists("TSCreateMultiTimeseriesReq.compressors", &f_5)?;
    let ret = TSCreateMultiTimeseriesReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      paths: f_2.expect("auto-generated code should have checked for presence of required fields"),
      data_types: f_3.expect("auto-generated code should have checked for presence of required fields"),
      encodings: f_4.expect("auto-generated code should have checked for presence of required fields"),
      compressors: f_5.expect("auto-generated code should have checked for presence of required fields"),
      props_list: f_6,
      tags_list: f_7,
      attributes_list: f_8,
      measurement_alias_list: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSCreateMultiTimeseriesReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("paths", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.paths.len() as i32))?;
    for e in &self.paths {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dataTypes", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.data_types.len() as i32))?;
    for e in &self.data_types {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encodings", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.encodings.len() as i32))?;
    for e in &self.encodings {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("compressors", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.compressors.len() as i32))?;
    for e in &self.compressors {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.props_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("propsList", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Map, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, e.len() as i32))?;
        for (k, v) in e {
          o_prot.write_string(k)?;
          o_prot.write_string(v)?;
        }
        o_prot.write_map_end()?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tags_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("tagsList", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Map, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, e.len() as i32))?;
        for (k, v) in e {
          o_prot.write_string(k)?;
          o_prot.write_string(v)?;
        }
        o_prot.write_map_end()?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.attributes_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("attributesList", TType::List, 8))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Map, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, e.len() as i32))?;
        for (k, v) in e {
          o_prot.write_string(k)?;
          o_prot.write_string(v)?;
        }
        o_prot.write_map_end()?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.measurement_alias_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("measurementAliasList", TType::List, 9))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServerProperties
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ServerProperties {
  pub version: String,
  pub supported_time_aggregation_operations: Vec<String>,
  pub timestamp_precision: String,
  pub max_concurrent_client_num: Option<i32>,
  pub watermark_secret_key: Option<String>,
  pub watermark_bit_string: Option<String>,
  pub watermark_param_mark_rate: Option<i32>,
  pub watermark_param_max_right_bit: Option<i32>,
  pub thrift_max_frame_size: Option<i32>,
  pub is_read_only: Option<bool>,
}

impl ServerProperties {
  pub fn new<F4, F5, F6, F7, F8, F9, F10>(version: String, supported_time_aggregation_operations: Vec<String>, timestamp_precision: String, max_concurrent_client_num: F4, watermark_secret_key: F5, watermark_bit_string: F6, watermark_param_mark_rate: F7, watermark_param_max_right_bit: F8, thrift_max_frame_size: F9, is_read_only: F10) -> ServerProperties where F4: Into<Option<i32>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<i32>>, F8: Into<Option<i32>>, F9: Into<Option<i32>>, F10: Into<Option<bool>> {
    ServerProperties {
      version,
      supported_time_aggregation_operations,
      timestamp_precision,
      max_concurrent_client_num: max_concurrent_client_num.into(),
      watermark_secret_key: watermark_secret_key.into(),
      watermark_bit_string: watermark_bit_string.into(),
      watermark_param_mark_rate: watermark_param_mark_rate.into(),
      watermark_param_max_right_bit: watermark_param_max_right_bit.into(),
      thrift_max_frame_size: thrift_max_frame_size.into(),
      is_read_only: is_read_only.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServerProperties> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = Some(0);
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<i32> = None;
    let mut f_8: Option<i32> = None;
    let mut f_9: Option<i32> = None;
    let mut f_10: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_85 = i_prot.read_string()?;
            val.push(list_elem_85);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i32()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServerProperties.version", &f_1)?;
    verify_required_field_exists("ServerProperties.supported_time_aggregation_operations", &f_2)?;
    verify_required_field_exists("ServerProperties.timestamp_precision", &f_3)?;
    let ret = ServerProperties {
      version: f_1.expect("auto-generated code should have checked for presence of required fields"),
      supported_time_aggregation_operations: f_2.expect("auto-generated code should have checked for presence of required fields"),
      timestamp_precision: f_3.expect("auto-generated code should have checked for presence of required fields"),
      max_concurrent_client_num: f_4,
      watermark_secret_key: f_5,
      watermark_bit_string: f_6,
      watermark_param_mark_rate: f_7,
      watermark_param_max_right_bit: f_8,
      thrift_max_frame_size: f_9,
      is_read_only: f_10,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServerProperties");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::String, 1))?;
    o_prot.write_string(&self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("supportedTimeAggregationOperations", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.supported_time_aggregation_operations.len() as i32))?;
    for e in &self.supported_time_aggregation_operations {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestampPrecision", TType::String, 3))?;
    o_prot.write_string(&self.timestamp_precision)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.max_concurrent_client_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("maxConcurrentClientNum", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.watermark_secret_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("watermarkSecretKey", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.watermark_bit_string {
      o_prot.write_field_begin(&TFieldIdentifier::new("watermarkBitString", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.watermark_param_mark_rate {
      o_prot.write_field_begin(&TFieldIdentifier::new("watermarkParamMarkRate", TType::I32, 7))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.watermark_param_max_right_bit {
      o_prot.write_field_begin(&TFieldIdentifier::new("watermarkParamMaxRightBit", TType::I32, 8))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.thrift_max_frame_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("thriftMaxFrameSize", TType::I32, 9))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_read_only {
      o_prot.write_field_begin(&TFieldIdentifier::new("isReadOnly", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSSetSchemaTemplateReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSSetSchemaTemplateReq {
  pub session_id: i64,
  pub template_name: String,
  pub prefix_path: String,
}

impl TSSetSchemaTemplateReq {
  pub fn new(session_id: i64, template_name: String, prefix_path: String) -> TSSetSchemaTemplateReq {
    TSSetSchemaTemplateReq {
      session_id,
      template_name,
      prefix_path,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSSetSchemaTemplateReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSSetSchemaTemplateReq.session_id", &f_1)?;
    verify_required_field_exists("TSSetSchemaTemplateReq.template_name", &f_2)?;
    verify_required_field_exists("TSSetSchemaTemplateReq.prefix_path", &f_3)?;
    let ret = TSSetSchemaTemplateReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      template_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      prefix_path: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSSetSchemaTemplateReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("templateName", TType::String, 2))?;
    o_prot.write_string(&self.template_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixPath", TType::String, 3))?;
    o_prot.write_string(&self.prefix_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSCreateSchemaTemplateReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSCreateSchemaTemplateReq {
  pub session_id: i64,
  pub name: String,
  pub serialized_template: Vec<u8>,
}

impl TSCreateSchemaTemplateReq {
  pub fn new(session_id: i64, name: String, serialized_template: Vec<u8>) -> TSCreateSchemaTemplateReq {
    TSCreateSchemaTemplateReq {
      session_id,
      name,
      serialized_template,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSCreateSchemaTemplateReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSCreateSchemaTemplateReq.session_id", &f_1)?;
    verify_required_field_exists("TSCreateSchemaTemplateReq.name", &f_2)?;
    verify_required_field_exists("TSCreateSchemaTemplateReq.serialized_template", &f_3)?;
    let ret = TSCreateSchemaTemplateReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      serialized_template: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSCreateSchemaTemplateReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("serializedTemplate", TType::String, 3))?;
    o_prot.write_bytes(&self.serialized_template)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSAppendSchemaTemplateReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSAppendSchemaTemplateReq {
  pub session_id: i64,
  pub name: String,
  pub is_aligned: bool,
  pub measurements: Vec<String>,
  pub data_types: Vec<i32>,
  pub encodings: Vec<i32>,
  pub compressors: Vec<i32>,
}

impl TSAppendSchemaTemplateReq {
  pub fn new(session_id: i64, name: String, is_aligned: bool, measurements: Vec<String>, data_types: Vec<i32>, encodings: Vec<i32>, compressors: Vec<i32>) -> TSAppendSchemaTemplateReq {
    TSAppendSchemaTemplateReq {
      session_id,
      name,
      is_aligned,
      measurements,
      data_types,
      encodings,
      compressors,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSAppendSchemaTemplateReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<Vec<String>> = None;
    let mut f_5: Option<Vec<i32>> = None;
    let mut f_6: Option<Vec<i32>> = None;
    let mut f_7: Option<Vec<i32>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_86 = i_prot.read_string()?;
            val.push(list_elem_86);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_87 = i_prot.read_i32()?;
            val.push(list_elem_87);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_88 = i_prot.read_i32()?;
            val.push(list_elem_88);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_89 = i_prot.read_i32()?;
            val.push(list_elem_89);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSAppendSchemaTemplateReq.session_id", &f_1)?;
    verify_required_field_exists("TSAppendSchemaTemplateReq.name", &f_2)?;
    verify_required_field_exists("TSAppendSchemaTemplateReq.is_aligned", &f_3)?;
    verify_required_field_exists("TSAppendSchemaTemplateReq.measurements", &f_4)?;
    verify_required_field_exists("TSAppendSchemaTemplateReq.data_types", &f_5)?;
    verify_required_field_exists("TSAppendSchemaTemplateReq.encodings", &f_6)?;
    verify_required_field_exists("TSAppendSchemaTemplateReq.compressors", &f_7)?;
    let ret = TSAppendSchemaTemplateReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      is_aligned: f_3.expect("auto-generated code should have checked for presence of required fields"),
      measurements: f_4.expect("auto-generated code should have checked for presence of required fields"),
      data_types: f_5.expect("auto-generated code should have checked for presence of required fields"),
      encodings: f_6.expect("auto-generated code should have checked for presence of required fields"),
      compressors: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSAppendSchemaTemplateReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("isAligned", TType::Bool, 3))?;
    o_prot.write_bool(self.is_aligned)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("measurements", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.measurements.len() as i32))?;
    for e in &self.measurements {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dataTypes", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.data_types.len() as i32))?;
    for e in &self.data_types {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encodings", TType::List, 6))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.encodings.len() as i32))?;
    for e in &self.encodings {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("compressors", TType::List, 7))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.compressors.len() as i32))?;
    for e in &self.compressors {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSPruneSchemaTemplateReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSPruneSchemaTemplateReq {
  pub session_id: i64,
  pub name: String,
  pub path: String,
}

impl TSPruneSchemaTemplateReq {
  pub fn new(session_id: i64, name: String, path: String) -> TSPruneSchemaTemplateReq {
    TSPruneSchemaTemplateReq {
      session_id,
      name,
      path,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSPruneSchemaTemplateReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSPruneSchemaTemplateReq.session_id", &f_1)?;
    verify_required_field_exists("TSPruneSchemaTemplateReq.name", &f_2)?;
    verify_required_field_exists("TSPruneSchemaTemplateReq.path", &f_3)?;
    let ret = TSPruneSchemaTemplateReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      path: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSPruneSchemaTemplateReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("path", TType::String, 3))?;
    o_prot.write_string(&self.path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSQueryTemplateReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSQueryTemplateReq {
  pub session_id: i64,
  pub name: String,
  pub query_type: i32,
  pub measurement: Option<String>,
}

impl TSQueryTemplateReq {
  pub fn new<F4>(session_id: i64, name: String, query_type: i32, measurement: F4) -> TSQueryTemplateReq where F4: Into<Option<String>> {
    TSQueryTemplateReq {
      session_id,
      name,
      query_type,
      measurement: measurement.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSQueryTemplateReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSQueryTemplateReq.session_id", &f_1)?;
    verify_required_field_exists("TSQueryTemplateReq.name", &f_2)?;
    verify_required_field_exists("TSQueryTemplateReq.query_type", &f_3)?;
    let ret = TSQueryTemplateReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      query_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
      measurement: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSQueryTemplateReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("queryType", TType::I32, 3))?;
    o_prot.write_i32(self.query_type)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.measurement {
      o_prot.write_field_begin(&TFieldIdentifier::new("measurement", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSQueryTemplateResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSQueryTemplateResp {
  pub status: common::TSStatus,
  pub query_type: i32,
  pub result: Option<bool>,
  pub count: Option<i32>,
  pub measurements: Option<Vec<String>>,
}

impl TSQueryTemplateResp {
  pub fn new<F3, F4, F5>(status: common::TSStatus, query_type: i32, result: F3, count: F4, measurements: F5) -> TSQueryTemplateResp where F3: Into<Option<bool>>, F4: Into<Option<i32>>, F5: Into<Option<Vec<String>>> {
    TSQueryTemplateResp {
      status,
      query_type,
      result: result.into(),
      count: count.into(),
      measurements: measurements.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSQueryTemplateResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<common::TSStatus> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_90 = i_prot.read_string()?;
            val.push(list_elem_90);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSQueryTemplateResp.status", &f_1)?;
    verify_required_field_exists("TSQueryTemplateResp.query_type", &f_2)?;
    let ret = TSQueryTemplateResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      result: f_3,
      count: f_4,
      measurements: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSQueryTemplateResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("queryType", TType::I32, 2))?;
    o_prot.write_i32(self.query_type)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.result {
      o_prot.write_field_begin(&TFieldIdentifier::new("result", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.count {
      o_prot.write_field_begin(&TFieldIdentifier::new("count", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.measurements {
      o_prot.write_field_begin(&TFieldIdentifier::new("measurements", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSUnsetSchemaTemplateReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSUnsetSchemaTemplateReq {
  pub session_id: i64,
  pub prefix_path: String,
  pub template_name: String,
}

impl TSUnsetSchemaTemplateReq {
  pub fn new(session_id: i64, prefix_path: String, template_name: String) -> TSUnsetSchemaTemplateReq {
    TSUnsetSchemaTemplateReq {
      session_id,
      prefix_path,
      template_name,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSUnsetSchemaTemplateReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSUnsetSchemaTemplateReq.session_id", &f_1)?;
    verify_required_field_exists("TSUnsetSchemaTemplateReq.prefix_path", &f_2)?;
    verify_required_field_exists("TSUnsetSchemaTemplateReq.template_name", &f_3)?;
    let ret = TSUnsetSchemaTemplateReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prefix_path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      template_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSUnsetSchemaTemplateReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixPath", TType::String, 2))?;
    o_prot.write_string(&self.prefix_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("templateName", TType::String, 3))?;
    o_prot.write_string(&self.template_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSDropSchemaTemplateReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSDropSchemaTemplateReq {
  pub session_id: i64,
  pub template_name: String,
}

impl TSDropSchemaTemplateReq {
  pub fn new(session_id: i64, template_name: String) -> TSDropSchemaTemplateReq {
    TSDropSchemaTemplateReq {
      session_id,
      template_name,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSDropSchemaTemplateReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSDropSchemaTemplateReq.session_id", &f_1)?;
    verify_required_field_exists("TSDropSchemaTemplateReq.template_name", &f_2)?;
    let ret = TSDropSchemaTemplateReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      template_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSDropSchemaTemplateReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("templateName", TType::String, 2))?;
    o_prot.write_string(&self.template_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCService service client
//

pub trait TIClientRPCServiceSyncClient {
  fn open_session(&mut self, req: TSOpenSessionReq) -> thrift::Result<TSOpenSessionResp>;
  fn close_session(&mut self, req: TSCloseSessionReq) -> thrift::Result<common::TSStatus>;
  fn execute_statement(&mut self, req: TSExecuteStatementReq) -> thrift::Result<TSExecuteStatementResp>;
  fn execute_batch_statement(&mut self, req: TSExecuteBatchStatementReq) -> thrift::Result<common::TSStatus>;
  fn execute_query_statement(&mut self, req: TSExecuteStatementReq) -> thrift::Result<TSExecuteStatementResp>;
  fn execute_update_statement(&mut self, req: TSExecuteStatementReq) -> thrift::Result<TSExecuteStatementResp>;
  fn fetch_results(&mut self, req: TSFetchResultsReq) -> thrift::Result<TSFetchResultsResp>;
  fn fetch_metadata(&mut self, req: TSFetchMetadataReq) -> thrift::Result<TSFetchMetadataResp>;
  fn cancel_operation(&mut self, req: TSCancelOperationReq) -> thrift::Result<common::TSStatus>;
  fn close_operation(&mut self, req: TSCloseOperationReq) -> thrift::Result<common::TSStatus>;
  fn get_time_zone(&mut self, session_id: i64) -> thrift::Result<TSGetTimeZoneResp>;
  fn set_time_zone(&mut self, req: TSSetTimeZoneReq) -> thrift::Result<common::TSStatus>;
  fn get_properties(&mut self) -> thrift::Result<ServerProperties>;
  fn set_storage_group(&mut self, session_id: i64, storage_group: String) -> thrift::Result<common::TSStatus>;
  fn create_timeseries(&mut self, req: TSCreateTimeseriesReq) -> thrift::Result<common::TSStatus>;
  fn create_aligned_timeseries(&mut self, req: TSCreateAlignedTimeseriesReq) -> thrift::Result<common::TSStatus>;
  fn create_multi_timeseries(&mut self, req: TSCreateMultiTimeseriesReq) -> thrift::Result<common::TSStatus>;
  fn delete_timeseries(&mut self, session_id: i64, path: Vec<String>) -> thrift::Result<common::TSStatus>;
  fn delete_storage_groups(&mut self, session_id: i64, storage_group: Vec<String>) -> thrift::Result<common::TSStatus>;
  fn insert_record(&mut self, req: TSInsertRecordReq) -> thrift::Result<common::TSStatus>;
  fn insert_string_record(&mut self, req: TSInsertStringRecordReq) -> thrift::Result<common::TSStatus>;
  fn insert_tablet(&mut self, req: TSInsertTabletReq) -> thrift::Result<common::TSStatus>;
  fn insert_tablets(&mut self, req: TSInsertTabletsReq) -> thrift::Result<common::TSStatus>;
  fn insert_records(&mut self, req: TSInsertRecordsReq) -> thrift::Result<common::TSStatus>;
  fn insert_records_of_one_device(&mut self, req: TSInsertRecordsOfOneDeviceReq) -> thrift::Result<common::TSStatus>;
  fn insert_string_records_of_one_device(&mut self, req: TSInsertStringRecordsOfOneDeviceReq) -> thrift::Result<common::TSStatus>;
  fn insert_string_records(&mut self, req: TSInsertStringRecordsReq) -> thrift::Result<common::TSStatus>;
  fn test_insert_tablet(&mut self, req: TSInsertTabletReq) -> thrift::Result<common::TSStatus>;
  fn test_insert_tablets(&mut self, req: TSInsertTabletsReq) -> thrift::Result<common::TSStatus>;
  fn test_insert_record(&mut self, req: TSInsertRecordReq) -> thrift::Result<common::TSStatus>;
  fn test_insert_string_record(&mut self, req: TSInsertStringRecordReq) -> thrift::Result<common::TSStatus>;
  fn test_insert_records(&mut self, req: TSInsertRecordsReq) -> thrift::Result<common::TSStatus>;
  fn test_insert_records_of_one_device(&mut self, req: TSInsertRecordsOfOneDeviceReq) -> thrift::Result<common::TSStatus>;
  fn test_insert_string_records(&mut self, req: TSInsertStringRecordsReq) -> thrift::Result<common::TSStatus>;
  fn delete_data(&mut self, req: TSDeleteDataReq) -> thrift::Result<common::TSStatus>;
  fn execute_raw_data_query(&mut self, req: TSRawDataQueryReq) -> thrift::Result<TSExecuteStatementResp>;
  fn execute_last_data_query(&mut self, req: TSLastDataQueryReq) -> thrift::Result<TSExecuteStatementResp>;
  fn request_statement_id(&mut self, session_id: i64) -> thrift::Result<i64>;
  fn create_schema_template(&mut self, req: TSCreateSchemaTemplateReq) -> thrift::Result<common::TSStatus>;
  fn append_schema_template(&mut self, req: TSAppendSchemaTemplateReq) -> thrift::Result<common::TSStatus>;
  fn prune_schema_template(&mut self, req: TSPruneSchemaTemplateReq) -> thrift::Result<common::TSStatus>;
  fn query_schema_template(&mut self, req: TSQueryTemplateReq) -> thrift::Result<TSQueryTemplateResp>;
  fn set_schema_template(&mut self, req: TSSetSchemaTemplateReq) -> thrift::Result<common::TSStatus>;
  fn unset_schema_template(&mut self, req: TSUnsetSchemaTemplateReq) -> thrift::Result<common::TSStatus>;
  fn drop_schema_template(&mut self, req: TSDropSchemaTemplateReq) -> thrift::Result<common::TSStatus>;
}

pub trait TIClientRPCServiceSyncClientMarker {}

pub struct IClientRPCServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> IClientRPCServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> IClientRPCServiceSyncClient<IP, OP> {
    IClientRPCServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for IClientRPCServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TIClientRPCServiceSyncClientMarker for IClientRPCServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TIClientRPCServiceSyncClientMarker> TIClientRPCServiceSyncClient for C {
  fn open_session(&mut self, req: TSOpenSessionReq) -> thrift::Result<TSOpenSessionResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("openSession", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceOpenSessionArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("openSession", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceOpenSessionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn close_session(&mut self, req: TSCloseSessionReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("closeSession", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceCloseSessionArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("closeSession", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceCloseSessionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn execute_statement(&mut self, req: TSExecuteStatementReq) -> thrift::Result<TSExecuteStatementResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("executeStatement", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceExecuteStatementArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("executeStatement", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceExecuteStatementResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn execute_batch_statement(&mut self, req: TSExecuteBatchStatementReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("executeBatchStatement", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceExecuteBatchStatementArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("executeBatchStatement", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceExecuteBatchStatementResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn execute_query_statement(&mut self, req: TSExecuteStatementReq) -> thrift::Result<TSExecuteStatementResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("executeQueryStatement", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceExecuteQueryStatementArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("executeQueryStatement", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceExecuteQueryStatementResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn execute_update_statement(&mut self, req: TSExecuteStatementReq) -> thrift::Result<TSExecuteStatementResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("executeUpdateStatement", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceExecuteUpdateStatementArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("executeUpdateStatement", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceExecuteUpdateStatementResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn fetch_results(&mut self, req: TSFetchResultsReq) -> thrift::Result<TSFetchResultsResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("fetchResults", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceFetchResultsArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("fetchResults", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceFetchResultsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn fetch_metadata(&mut self, req: TSFetchMetadataReq) -> thrift::Result<TSFetchMetadataResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("fetchMetadata", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceFetchMetadataArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("fetchMetadata", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceFetchMetadataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn cancel_operation(&mut self, req: TSCancelOperationReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("cancelOperation", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceCancelOperationArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("cancelOperation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceCancelOperationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn close_operation(&mut self, req: TSCloseOperationReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("closeOperation", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceCloseOperationArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("closeOperation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceCloseOperationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_time_zone(&mut self, session_id: i64) -> thrift::Result<TSGetTimeZoneResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getTimeZone", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceGetTimeZoneArgs { session_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getTimeZone", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceGetTimeZoneResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_time_zone(&mut self, req: TSSetTimeZoneReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("setTimeZone", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceSetTimeZoneArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("setTimeZone", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceSetTimeZoneResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_properties(&mut self) -> thrift::Result<ServerProperties> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getProperties", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceGetPropertiesArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getProperties", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceGetPropertiesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_storage_group(&mut self, session_id: i64, storage_group: String) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("setStorageGroup", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceSetStorageGroupArgs { session_id, storage_group };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("setStorageGroup", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceSetStorageGroupResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_timeseries(&mut self, req: TSCreateTimeseriesReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("createTimeseries", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceCreateTimeseriesArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("createTimeseries", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceCreateTimeseriesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_aligned_timeseries(&mut self, req: TSCreateAlignedTimeseriesReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("createAlignedTimeseries", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceCreateAlignedTimeseriesArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("createAlignedTimeseries", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceCreateAlignedTimeseriesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_multi_timeseries(&mut self, req: TSCreateMultiTimeseriesReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("createMultiTimeseries", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceCreateMultiTimeseriesArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("createMultiTimeseries", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceCreateMultiTimeseriesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn delete_timeseries(&mut self, session_id: i64, path: Vec<String>) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("deleteTimeseries", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceDeleteTimeseriesArgs { session_id, path };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("deleteTimeseries", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceDeleteTimeseriesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn delete_storage_groups(&mut self, session_id: i64, storage_group: Vec<String>) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("deleteStorageGroups", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceDeleteStorageGroupsArgs { session_id, storage_group };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("deleteStorageGroups", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceDeleteStorageGroupsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn insert_record(&mut self, req: TSInsertRecordReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("insertRecord", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceInsertRecordArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("insertRecord", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceInsertRecordResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn insert_string_record(&mut self, req: TSInsertStringRecordReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("insertStringRecord", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceInsertStringRecordArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("insertStringRecord", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceInsertStringRecordResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn insert_tablet(&mut self, req: TSInsertTabletReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("insertTablet", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceInsertTabletArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("insertTablet", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceInsertTabletResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn insert_tablets(&mut self, req: TSInsertTabletsReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("insertTablets", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceInsertTabletsArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("insertTablets", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceInsertTabletsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn insert_records(&mut self, req: TSInsertRecordsReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("insertRecords", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceInsertRecordsArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("insertRecords", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceInsertRecordsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn insert_records_of_one_device(&mut self, req: TSInsertRecordsOfOneDeviceReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("insertRecordsOfOneDevice", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceInsertRecordsOfOneDeviceArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("insertRecordsOfOneDevice", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceInsertRecordsOfOneDeviceResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn insert_string_records_of_one_device(&mut self, req: TSInsertStringRecordsOfOneDeviceReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("insertStringRecordsOfOneDevice", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceInsertStringRecordsOfOneDeviceArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("insertStringRecordsOfOneDevice", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceInsertStringRecordsOfOneDeviceResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn insert_string_records(&mut self, req: TSInsertStringRecordsReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("insertStringRecords", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceInsertStringRecordsArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("insertStringRecords", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceInsertStringRecordsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn test_insert_tablet(&mut self, req: TSInsertTabletReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("testInsertTablet", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceTestInsertTabletArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("testInsertTablet", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceTestInsertTabletResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn test_insert_tablets(&mut self, req: TSInsertTabletsReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("testInsertTablets", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceTestInsertTabletsArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("testInsertTablets", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceTestInsertTabletsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn test_insert_record(&mut self, req: TSInsertRecordReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("testInsertRecord", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceTestInsertRecordArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("testInsertRecord", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceTestInsertRecordResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn test_insert_string_record(&mut self, req: TSInsertStringRecordReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("testInsertStringRecord", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceTestInsertStringRecordArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("testInsertStringRecord", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceTestInsertStringRecordResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn test_insert_records(&mut self, req: TSInsertRecordsReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("testInsertRecords", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceTestInsertRecordsArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("testInsertRecords", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceTestInsertRecordsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn test_insert_records_of_one_device(&mut self, req: TSInsertRecordsOfOneDeviceReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("testInsertRecordsOfOneDevice", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceTestInsertRecordsOfOneDeviceArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("testInsertRecordsOfOneDevice", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceTestInsertRecordsOfOneDeviceResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn test_insert_string_records(&mut self, req: TSInsertStringRecordsReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("testInsertStringRecords", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceTestInsertStringRecordsArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("testInsertStringRecords", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceTestInsertStringRecordsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn delete_data(&mut self, req: TSDeleteDataReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("deleteData", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceDeleteDataArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("deleteData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceDeleteDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn execute_raw_data_query(&mut self, req: TSRawDataQueryReq) -> thrift::Result<TSExecuteStatementResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("executeRawDataQuery", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceExecuteRawDataQueryArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("executeRawDataQuery", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceExecuteRawDataQueryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn execute_last_data_query(&mut self, req: TSLastDataQueryReq) -> thrift::Result<TSExecuteStatementResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("executeLastDataQuery", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceExecuteLastDataQueryArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("executeLastDataQuery", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceExecuteLastDataQueryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn request_statement_id(&mut self, session_id: i64) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("requestStatementId", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceRequestStatementIdArgs { session_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("requestStatementId", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceRequestStatementIdResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_schema_template(&mut self, req: TSCreateSchemaTemplateReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("createSchemaTemplate", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceCreateSchemaTemplateArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("createSchemaTemplate", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceCreateSchemaTemplateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn append_schema_template(&mut self, req: TSAppendSchemaTemplateReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("appendSchemaTemplate", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceAppendSchemaTemplateArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("appendSchemaTemplate", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceAppendSchemaTemplateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn prune_schema_template(&mut self, req: TSPruneSchemaTemplateReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("pruneSchemaTemplate", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServicePruneSchemaTemplateArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("pruneSchemaTemplate", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServicePruneSchemaTemplateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn query_schema_template(&mut self, req: TSQueryTemplateReq) -> thrift::Result<TSQueryTemplateResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("querySchemaTemplate", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceQuerySchemaTemplateArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("querySchemaTemplate", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceQuerySchemaTemplateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_schema_template(&mut self, req: TSSetSchemaTemplateReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("setSchemaTemplate", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceSetSchemaTemplateArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("setSchemaTemplate", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceSetSchemaTemplateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn unset_schema_template(&mut self, req: TSUnsetSchemaTemplateReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("unsetSchemaTemplate", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceUnsetSchemaTemplateArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("unsetSchemaTemplate", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceUnsetSchemaTemplateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn drop_schema_template(&mut self, req: TSDropSchemaTemplateReq) -> thrift::Result<common::TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("dropSchemaTemplate", TMessageType::Call, self.sequence_number());
        let call_args = IClientRPCServiceDropSchemaTemplateArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("dropSchemaTemplate", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = IClientRPCServiceDropSchemaTemplateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// IClientRPCService service processor
//

pub trait IClientRPCServiceSyncHandler {
  fn handle_open_session(&self, req: TSOpenSessionReq) -> thrift::Result<TSOpenSessionResp>;
  fn handle_close_session(&self, req: TSCloseSessionReq) -> thrift::Result<common::TSStatus>;
  fn handle_execute_statement(&self, req: TSExecuteStatementReq) -> thrift::Result<TSExecuteStatementResp>;
  fn handle_execute_batch_statement(&self, req: TSExecuteBatchStatementReq) -> thrift::Result<common::TSStatus>;
  fn handle_execute_query_statement(&self, req: TSExecuteStatementReq) -> thrift::Result<TSExecuteStatementResp>;
  fn handle_execute_update_statement(&self, req: TSExecuteStatementReq) -> thrift::Result<TSExecuteStatementResp>;
  fn handle_fetch_results(&self, req: TSFetchResultsReq) -> thrift::Result<TSFetchResultsResp>;
  fn handle_fetch_metadata(&self, req: TSFetchMetadataReq) -> thrift::Result<TSFetchMetadataResp>;
  fn handle_cancel_operation(&self, req: TSCancelOperationReq) -> thrift::Result<common::TSStatus>;
  fn handle_close_operation(&self, req: TSCloseOperationReq) -> thrift::Result<common::TSStatus>;
  fn handle_get_time_zone(&self, session_id: i64) -> thrift::Result<TSGetTimeZoneResp>;
  fn handle_set_time_zone(&self, req: TSSetTimeZoneReq) -> thrift::Result<common::TSStatus>;
  fn handle_get_properties(&self) -> thrift::Result<ServerProperties>;
  fn handle_set_storage_group(&self, session_id: i64, storage_group: String) -> thrift::Result<common::TSStatus>;
  fn handle_create_timeseries(&self, req: TSCreateTimeseriesReq) -> thrift::Result<common::TSStatus>;
  fn handle_create_aligned_timeseries(&self, req: TSCreateAlignedTimeseriesReq) -> thrift::Result<common::TSStatus>;
  fn handle_create_multi_timeseries(&self, req: TSCreateMultiTimeseriesReq) -> thrift::Result<common::TSStatus>;
  fn handle_delete_timeseries(&self, session_id: i64, path: Vec<String>) -> thrift::Result<common::TSStatus>;
  fn handle_delete_storage_groups(&self, session_id: i64, storage_group: Vec<String>) -> thrift::Result<common::TSStatus>;
  fn handle_insert_record(&self, req: TSInsertRecordReq) -> thrift::Result<common::TSStatus>;
  fn handle_insert_string_record(&self, req: TSInsertStringRecordReq) -> thrift::Result<common::TSStatus>;
  fn handle_insert_tablet(&self, req: TSInsertTabletReq) -> thrift::Result<common::TSStatus>;
  fn handle_insert_tablets(&self, req: TSInsertTabletsReq) -> thrift::Result<common::TSStatus>;
  fn handle_insert_records(&self, req: TSInsertRecordsReq) -> thrift::Result<common::TSStatus>;
  fn handle_insert_records_of_one_device(&self, req: TSInsertRecordsOfOneDeviceReq) -> thrift::Result<common::TSStatus>;
  fn handle_insert_string_records_of_one_device(&self, req: TSInsertStringRecordsOfOneDeviceReq) -> thrift::Result<common::TSStatus>;
  fn handle_insert_string_records(&self, req: TSInsertStringRecordsReq) -> thrift::Result<common::TSStatus>;
  fn handle_test_insert_tablet(&self, req: TSInsertTabletReq) -> thrift::Result<common::TSStatus>;
  fn handle_test_insert_tablets(&self, req: TSInsertTabletsReq) -> thrift::Result<common::TSStatus>;
  fn handle_test_insert_record(&self, req: TSInsertRecordReq) -> thrift::Result<common::TSStatus>;
  fn handle_test_insert_string_record(&self, req: TSInsertStringRecordReq) -> thrift::Result<common::TSStatus>;
  fn handle_test_insert_records(&self, req: TSInsertRecordsReq) -> thrift::Result<common::TSStatus>;
  fn handle_test_insert_records_of_one_device(&self, req: TSInsertRecordsOfOneDeviceReq) -> thrift::Result<common::TSStatus>;
  fn handle_test_insert_string_records(&self, req: TSInsertStringRecordsReq) -> thrift::Result<common::TSStatus>;
  fn handle_delete_data(&self, req: TSDeleteDataReq) -> thrift::Result<common::TSStatus>;
  fn handle_execute_raw_data_query(&self, req: TSRawDataQueryReq) -> thrift::Result<TSExecuteStatementResp>;
  fn handle_execute_last_data_query(&self, req: TSLastDataQueryReq) -> thrift::Result<TSExecuteStatementResp>;
  fn handle_request_statement_id(&self, session_id: i64) -> thrift::Result<i64>;
  fn handle_create_schema_template(&self, req: TSCreateSchemaTemplateReq) -> thrift::Result<common::TSStatus>;
  fn handle_append_schema_template(&self, req: TSAppendSchemaTemplateReq) -> thrift::Result<common::TSStatus>;
  fn handle_prune_schema_template(&self, req: TSPruneSchemaTemplateReq) -> thrift::Result<common::TSStatus>;
  fn handle_query_schema_template(&self, req: TSQueryTemplateReq) -> thrift::Result<TSQueryTemplateResp>;
  fn handle_set_schema_template(&self, req: TSSetSchemaTemplateReq) -> thrift::Result<common::TSStatus>;
  fn handle_unset_schema_template(&self, req: TSUnsetSchemaTemplateReq) -> thrift::Result<common::TSStatus>;
  fn handle_drop_schema_template(&self, req: TSDropSchemaTemplateReq) -> thrift::Result<common::TSStatus>;
}

pub struct IClientRPCServiceSyncProcessor<H: IClientRPCServiceSyncHandler> {
  handler: H,
}

impl <H: IClientRPCServiceSyncHandler> IClientRPCServiceSyncProcessor<H> {
  pub fn new(handler: H) -> IClientRPCServiceSyncProcessor<H> {
    IClientRPCServiceSyncProcessor {
      handler,
    }
  }
  fn process_open_session(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_open_session(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_close_session(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_close_session(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_execute_statement(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_execute_statement(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_execute_batch_statement(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_execute_batch_statement(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_execute_query_statement(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_execute_query_statement(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_execute_update_statement(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_execute_update_statement(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_fetch_results(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_fetch_results(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_fetch_metadata(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_fetch_metadata(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_cancel_operation(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_cancel_operation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_close_operation(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_close_operation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_time_zone(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_get_time_zone(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_time_zone(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_set_time_zone(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_properties(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_get_properties(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_storage_group(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_set_storage_group(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_timeseries(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_create_timeseries(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_aligned_timeseries(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_create_aligned_timeseries(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_multi_timeseries(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_create_multi_timeseries(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_delete_timeseries(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_delete_timeseries(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_delete_storage_groups(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_delete_storage_groups(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_insert_record(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_insert_record(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_insert_string_record(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_insert_string_record(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_insert_tablet(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_insert_tablet(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_insert_tablets(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_insert_tablets(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_insert_records(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_insert_records(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_insert_records_of_one_device(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_insert_records_of_one_device(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_insert_string_records_of_one_device(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_insert_string_records_of_one_device(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_insert_string_records(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_insert_string_records(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_test_insert_tablet(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_test_insert_tablet(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_test_insert_tablets(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_test_insert_tablets(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_test_insert_record(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_test_insert_record(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_test_insert_string_record(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_test_insert_string_record(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_test_insert_records(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_test_insert_records(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_test_insert_records_of_one_device(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_test_insert_records_of_one_device(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_test_insert_string_records(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_test_insert_string_records(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_delete_data(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_delete_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_execute_raw_data_query(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_execute_raw_data_query(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_execute_last_data_query(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_execute_last_data_query(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_request_statement_id(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_request_statement_id(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_schema_template(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_create_schema_template(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_append_schema_template(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_append_schema_template(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_prune_schema_template(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_prune_schema_template(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_query_schema_template(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_query_schema_template(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_schema_template(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_set_schema_template(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_unset_schema_template(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_unset_schema_template(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_drop_schema_template(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TIClientRPCServiceProcessFunctions::process_drop_schema_template(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TIClientRPCServiceProcessFunctions;

impl TIClientRPCServiceProcessFunctions {
  pub fn process_open_session<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceOpenSessionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_open_session(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("openSession", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceOpenSessionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("openSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("openSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_close_session<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceCloseSessionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_close_session(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("closeSession", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceCloseSessionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("closeSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("closeSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_execute_statement<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceExecuteStatementArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_execute_statement(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("executeStatement", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceExecuteStatementResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("executeStatement", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("executeStatement", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_execute_batch_statement<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceExecuteBatchStatementArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_execute_batch_statement(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("executeBatchStatement", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceExecuteBatchStatementResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("executeBatchStatement", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("executeBatchStatement", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_execute_query_statement<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceExecuteQueryStatementArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_execute_query_statement(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("executeQueryStatement", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceExecuteQueryStatementResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("executeQueryStatement", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("executeQueryStatement", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_execute_update_statement<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceExecuteUpdateStatementArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_execute_update_statement(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("executeUpdateStatement", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceExecuteUpdateStatementResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("executeUpdateStatement", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("executeUpdateStatement", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_fetch_results<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceFetchResultsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_fetch_results(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("fetchResults", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceFetchResultsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("fetchResults", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("fetchResults", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_fetch_metadata<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceFetchMetadataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_fetch_metadata(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("fetchMetadata", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceFetchMetadataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("fetchMetadata", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("fetchMetadata", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_cancel_operation<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceCancelOperationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_cancel_operation(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("cancelOperation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceCancelOperationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("cancelOperation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("cancelOperation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_close_operation<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceCloseOperationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_close_operation(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("closeOperation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceCloseOperationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("closeOperation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("closeOperation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_time_zone<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceGetTimeZoneArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_time_zone(args.session_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getTimeZone", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceGetTimeZoneResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getTimeZone", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getTimeZone", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_time_zone<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceSetTimeZoneArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_time_zone(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("setTimeZone", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceSetTimeZoneResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("setTimeZone", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("setTimeZone", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_properties<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = IClientRPCServiceGetPropertiesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_properties() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getProperties", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceGetPropertiesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getProperties", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getProperties", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_storage_group<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceSetStorageGroupArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_storage_group(args.session_id, args.storage_group) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("setStorageGroup", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceSetStorageGroupResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("setStorageGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("setStorageGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_timeseries<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceCreateTimeseriesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_timeseries(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("createTimeseries", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceCreateTimeseriesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("createTimeseries", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("createTimeseries", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_aligned_timeseries<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceCreateAlignedTimeseriesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_aligned_timeseries(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("createAlignedTimeseries", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceCreateAlignedTimeseriesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("createAlignedTimeseries", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("createAlignedTimeseries", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_multi_timeseries<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceCreateMultiTimeseriesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_multi_timeseries(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("createMultiTimeseries", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceCreateMultiTimeseriesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("createMultiTimeseries", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("createMultiTimeseries", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_delete_timeseries<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceDeleteTimeseriesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_delete_timeseries(args.session_id, args.path) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("deleteTimeseries", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceDeleteTimeseriesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("deleteTimeseries", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("deleteTimeseries", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_delete_storage_groups<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceDeleteStorageGroupsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_delete_storage_groups(args.session_id, args.storage_group) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("deleteStorageGroups", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceDeleteStorageGroupsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("deleteStorageGroups", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("deleteStorageGroups", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_insert_record<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceInsertRecordArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_insert_record(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("insertRecord", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceInsertRecordResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("insertRecord", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("insertRecord", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_insert_string_record<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceInsertStringRecordArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_insert_string_record(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("insertStringRecord", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceInsertStringRecordResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("insertStringRecord", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("insertStringRecord", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_insert_tablet<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceInsertTabletArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_insert_tablet(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("insertTablet", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceInsertTabletResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("insertTablet", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("insertTablet", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_insert_tablets<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceInsertTabletsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_insert_tablets(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("insertTablets", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceInsertTabletsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("insertTablets", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("insertTablets", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_insert_records<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceInsertRecordsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_insert_records(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("insertRecords", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceInsertRecordsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("insertRecords", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("insertRecords", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_insert_records_of_one_device<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceInsertRecordsOfOneDeviceArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_insert_records_of_one_device(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("insertRecordsOfOneDevice", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceInsertRecordsOfOneDeviceResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("insertRecordsOfOneDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("insertRecordsOfOneDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_insert_string_records_of_one_device<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceInsertStringRecordsOfOneDeviceArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_insert_string_records_of_one_device(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("insertStringRecordsOfOneDevice", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceInsertStringRecordsOfOneDeviceResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("insertStringRecordsOfOneDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("insertStringRecordsOfOneDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_insert_string_records<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceInsertStringRecordsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_insert_string_records(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("insertStringRecords", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceInsertStringRecordsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("insertStringRecords", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("insertStringRecords", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_test_insert_tablet<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceTestInsertTabletArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_test_insert_tablet(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("testInsertTablet", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceTestInsertTabletResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("testInsertTablet", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("testInsertTablet", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_test_insert_tablets<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceTestInsertTabletsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_test_insert_tablets(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("testInsertTablets", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceTestInsertTabletsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("testInsertTablets", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("testInsertTablets", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_test_insert_record<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceTestInsertRecordArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_test_insert_record(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("testInsertRecord", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceTestInsertRecordResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("testInsertRecord", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("testInsertRecord", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_test_insert_string_record<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceTestInsertStringRecordArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_test_insert_string_record(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("testInsertStringRecord", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceTestInsertStringRecordResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("testInsertStringRecord", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("testInsertStringRecord", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_test_insert_records<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceTestInsertRecordsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_test_insert_records(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("testInsertRecords", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceTestInsertRecordsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("testInsertRecords", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("testInsertRecords", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_test_insert_records_of_one_device<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceTestInsertRecordsOfOneDeviceArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_test_insert_records_of_one_device(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("testInsertRecordsOfOneDevice", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceTestInsertRecordsOfOneDeviceResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("testInsertRecordsOfOneDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("testInsertRecordsOfOneDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_test_insert_string_records<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceTestInsertStringRecordsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_test_insert_string_records(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("testInsertStringRecords", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceTestInsertStringRecordsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("testInsertStringRecords", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("testInsertStringRecords", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_delete_data<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceDeleteDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_delete_data(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("deleteData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceDeleteDataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("deleteData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("deleteData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_execute_raw_data_query<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceExecuteRawDataQueryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_execute_raw_data_query(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("executeRawDataQuery", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceExecuteRawDataQueryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("executeRawDataQuery", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("executeRawDataQuery", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_execute_last_data_query<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceExecuteLastDataQueryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_execute_last_data_query(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("executeLastDataQuery", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceExecuteLastDataQueryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("executeLastDataQuery", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("executeLastDataQuery", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_request_statement_id<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceRequestStatementIdArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_request_statement_id(args.session_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("requestStatementId", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceRequestStatementIdResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("requestStatementId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("requestStatementId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_schema_template<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceCreateSchemaTemplateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_schema_template(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("createSchemaTemplate", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceCreateSchemaTemplateResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("createSchemaTemplate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("createSchemaTemplate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_append_schema_template<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceAppendSchemaTemplateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_append_schema_template(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("appendSchemaTemplate", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceAppendSchemaTemplateResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("appendSchemaTemplate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("appendSchemaTemplate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_prune_schema_template<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServicePruneSchemaTemplateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_prune_schema_template(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("pruneSchemaTemplate", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServicePruneSchemaTemplateResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("pruneSchemaTemplate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("pruneSchemaTemplate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_query_schema_template<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceQuerySchemaTemplateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_query_schema_template(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("querySchemaTemplate", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceQuerySchemaTemplateResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("querySchemaTemplate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("querySchemaTemplate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_schema_template<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceSetSchemaTemplateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_schema_template(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("setSchemaTemplate", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceSetSchemaTemplateResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("setSchemaTemplate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("setSchemaTemplate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_unset_schema_template<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceUnsetSchemaTemplateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_unset_schema_template(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("unsetSchemaTemplate", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceUnsetSchemaTemplateResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("unsetSchemaTemplate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("unsetSchemaTemplate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_drop_schema_template<H: IClientRPCServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = IClientRPCServiceDropSchemaTemplateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_drop_schema_template(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("dropSchemaTemplate", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = IClientRPCServiceDropSchemaTemplateResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("dropSchemaTemplate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("dropSchemaTemplate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: IClientRPCServiceSyncHandler> TProcessor for IClientRPCServiceSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "openSession" => {
        self.process_open_session(message_ident.sequence_number, i_prot, o_prot)
      },
      "closeSession" => {
        self.process_close_session(message_ident.sequence_number, i_prot, o_prot)
      },
      "executeStatement" => {
        self.process_execute_statement(message_ident.sequence_number, i_prot, o_prot)
      },
      "executeBatchStatement" => {
        self.process_execute_batch_statement(message_ident.sequence_number, i_prot, o_prot)
      },
      "executeQueryStatement" => {
        self.process_execute_query_statement(message_ident.sequence_number, i_prot, o_prot)
      },
      "executeUpdateStatement" => {
        self.process_execute_update_statement(message_ident.sequence_number, i_prot, o_prot)
      },
      "fetchResults" => {
        self.process_fetch_results(message_ident.sequence_number, i_prot, o_prot)
      },
      "fetchMetadata" => {
        self.process_fetch_metadata(message_ident.sequence_number, i_prot, o_prot)
      },
      "cancelOperation" => {
        self.process_cancel_operation(message_ident.sequence_number, i_prot, o_prot)
      },
      "closeOperation" => {
        self.process_close_operation(message_ident.sequence_number, i_prot, o_prot)
      },
      "getTimeZone" => {
        self.process_get_time_zone(message_ident.sequence_number, i_prot, o_prot)
      },
      "setTimeZone" => {
        self.process_set_time_zone(message_ident.sequence_number, i_prot, o_prot)
      },
      "getProperties" => {
        self.process_get_properties(message_ident.sequence_number, i_prot, o_prot)
      },
      "setStorageGroup" => {
        self.process_set_storage_group(message_ident.sequence_number, i_prot, o_prot)
      },
      "createTimeseries" => {
        self.process_create_timeseries(message_ident.sequence_number, i_prot, o_prot)
      },
      "createAlignedTimeseries" => {
        self.process_create_aligned_timeseries(message_ident.sequence_number, i_prot, o_prot)
      },
      "createMultiTimeseries" => {
        self.process_create_multi_timeseries(message_ident.sequence_number, i_prot, o_prot)
      },
      "deleteTimeseries" => {
        self.process_delete_timeseries(message_ident.sequence_number, i_prot, o_prot)
      },
      "deleteStorageGroups" => {
        self.process_delete_storage_groups(message_ident.sequence_number, i_prot, o_prot)
      },
      "insertRecord" => {
        self.process_insert_record(message_ident.sequence_number, i_prot, o_prot)
      },
      "insertStringRecord" => {
        self.process_insert_string_record(message_ident.sequence_number, i_prot, o_prot)
      },
      "insertTablet" => {
        self.process_insert_tablet(message_ident.sequence_number, i_prot, o_prot)
      },
      "insertTablets" => {
        self.process_insert_tablets(message_ident.sequence_number, i_prot, o_prot)
      },
      "insertRecords" => {
        self.process_insert_records(message_ident.sequence_number, i_prot, o_prot)
      },
      "insertRecordsOfOneDevice" => {
        self.process_insert_records_of_one_device(message_ident.sequence_number, i_prot, o_prot)
      },
      "insertStringRecordsOfOneDevice" => {
        self.process_insert_string_records_of_one_device(message_ident.sequence_number, i_prot, o_prot)
      },
      "insertStringRecords" => {
        self.process_insert_string_records(message_ident.sequence_number, i_prot, o_prot)
      },
      "testInsertTablet" => {
        self.process_test_insert_tablet(message_ident.sequence_number, i_prot, o_prot)
      },
      "testInsertTablets" => {
        self.process_test_insert_tablets(message_ident.sequence_number, i_prot, o_prot)
      },
      "testInsertRecord" => {
        self.process_test_insert_record(message_ident.sequence_number, i_prot, o_prot)
      },
      "testInsertStringRecord" => {
        self.process_test_insert_string_record(message_ident.sequence_number, i_prot, o_prot)
      },
      "testInsertRecords" => {
        self.process_test_insert_records(message_ident.sequence_number, i_prot, o_prot)
      },
      "testInsertRecordsOfOneDevice" => {
        self.process_test_insert_records_of_one_device(message_ident.sequence_number, i_prot, o_prot)
      },
      "testInsertStringRecords" => {
        self.process_test_insert_string_records(message_ident.sequence_number, i_prot, o_prot)
      },
      "deleteData" => {
        self.process_delete_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "executeRawDataQuery" => {
        self.process_execute_raw_data_query(message_ident.sequence_number, i_prot, o_prot)
      },
      "executeLastDataQuery" => {
        self.process_execute_last_data_query(message_ident.sequence_number, i_prot, o_prot)
      },
      "requestStatementId" => {
        self.process_request_statement_id(message_ident.sequence_number, i_prot, o_prot)
      },
      "createSchemaTemplate" => {
        self.process_create_schema_template(message_ident.sequence_number, i_prot, o_prot)
      },
      "appendSchemaTemplate" => {
        self.process_append_schema_template(message_ident.sequence_number, i_prot, o_prot)
      },
      "pruneSchemaTemplate" => {
        self.process_prune_schema_template(message_ident.sequence_number, i_prot, o_prot)
      },
      "querySchemaTemplate" => {
        self.process_query_schema_template(message_ident.sequence_number, i_prot, o_prot)
      },
      "setSchemaTemplate" => {
        self.process_set_schema_template(message_ident.sequence_number, i_prot, o_prot)
      },
      "unsetSchemaTemplate" => {
        self.process_unset_schema_template(message_ident.sequence_number, i_prot, o_prot)
      },
      "dropSchemaTemplate" => {
        self.process_drop_schema_template(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// IClientRPCServiceOpenSessionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceOpenSessionArgs {
  req: TSOpenSessionReq,
}

impl IClientRPCServiceOpenSessionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceOpenSessionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSOpenSessionReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSOpenSessionReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceOpenSessionArgs.req", &f_1)?;
    let ret = IClientRPCServiceOpenSessionArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("openSession_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceOpenSessionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceOpenSessionResult {
  result_value: Option<TSOpenSessionResp>,
}

impl IClientRPCServiceOpenSessionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceOpenSessionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSOpenSessionResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSOpenSessionResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceOpenSessionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceOpenSessionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSOpenSessionResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceOpenSession"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceCloseSessionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceCloseSessionArgs {
  req: TSCloseSessionReq,
}

impl IClientRPCServiceCloseSessionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceCloseSessionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSCloseSessionReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSCloseSessionReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceCloseSessionArgs.req", &f_1)?;
    let ret = IClientRPCServiceCloseSessionArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("closeSession_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceCloseSessionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceCloseSessionResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceCloseSessionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceCloseSessionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceCloseSessionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceCloseSessionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceCloseSession"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceExecuteStatementArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceExecuteStatementArgs {
  req: TSExecuteStatementReq,
}

impl IClientRPCServiceExecuteStatementArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceExecuteStatementArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSExecuteStatementReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSExecuteStatementReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceExecuteStatementArgs.req", &f_1)?;
    let ret = IClientRPCServiceExecuteStatementArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("executeStatement_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceExecuteStatementResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceExecuteStatementResult {
  result_value: Option<TSExecuteStatementResp>,
}

impl IClientRPCServiceExecuteStatementResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceExecuteStatementResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSExecuteStatementResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSExecuteStatementResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceExecuteStatementResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceExecuteStatementResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSExecuteStatementResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceExecuteStatement"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceExecuteBatchStatementArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceExecuteBatchStatementArgs {
  req: TSExecuteBatchStatementReq,
}

impl IClientRPCServiceExecuteBatchStatementArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceExecuteBatchStatementArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSExecuteBatchStatementReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSExecuteBatchStatementReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceExecuteBatchStatementArgs.req", &f_1)?;
    let ret = IClientRPCServiceExecuteBatchStatementArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("executeBatchStatement_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceExecuteBatchStatementResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceExecuteBatchStatementResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceExecuteBatchStatementResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceExecuteBatchStatementResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceExecuteBatchStatementResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceExecuteBatchStatementResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceExecuteBatchStatement"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceExecuteQueryStatementArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceExecuteQueryStatementArgs {
  req: TSExecuteStatementReq,
}

impl IClientRPCServiceExecuteQueryStatementArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceExecuteQueryStatementArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSExecuteStatementReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSExecuteStatementReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceExecuteQueryStatementArgs.req", &f_1)?;
    let ret = IClientRPCServiceExecuteQueryStatementArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("executeQueryStatement_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceExecuteQueryStatementResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceExecuteQueryStatementResult {
  result_value: Option<TSExecuteStatementResp>,
}

impl IClientRPCServiceExecuteQueryStatementResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceExecuteQueryStatementResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSExecuteStatementResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSExecuteStatementResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceExecuteQueryStatementResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceExecuteQueryStatementResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSExecuteStatementResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceExecuteQueryStatement"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceExecuteUpdateStatementArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceExecuteUpdateStatementArgs {
  req: TSExecuteStatementReq,
}

impl IClientRPCServiceExecuteUpdateStatementArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceExecuteUpdateStatementArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSExecuteStatementReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSExecuteStatementReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceExecuteUpdateStatementArgs.req", &f_1)?;
    let ret = IClientRPCServiceExecuteUpdateStatementArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("executeUpdateStatement_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceExecuteUpdateStatementResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceExecuteUpdateStatementResult {
  result_value: Option<TSExecuteStatementResp>,
}

impl IClientRPCServiceExecuteUpdateStatementResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceExecuteUpdateStatementResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSExecuteStatementResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSExecuteStatementResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceExecuteUpdateStatementResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceExecuteUpdateStatementResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSExecuteStatementResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceExecuteUpdateStatement"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceFetchResultsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceFetchResultsArgs {
  req: TSFetchResultsReq,
}

impl IClientRPCServiceFetchResultsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceFetchResultsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSFetchResultsReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSFetchResultsReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceFetchResultsArgs.req", &f_1)?;
    let ret = IClientRPCServiceFetchResultsArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("fetchResults_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceFetchResultsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceFetchResultsResult {
  result_value: Option<TSFetchResultsResp>,
}

impl IClientRPCServiceFetchResultsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceFetchResultsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSFetchResultsResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSFetchResultsResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceFetchResultsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceFetchResultsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSFetchResultsResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceFetchsResult"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceFetchMetadataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceFetchMetadataArgs {
  req: TSFetchMetadataReq,
}

impl IClientRPCServiceFetchMetadataArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceFetchMetadataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSFetchMetadataReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSFetchMetadataReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceFetchMetadataArgs.req", &f_1)?;
    let ret = IClientRPCServiceFetchMetadataArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("fetchMetadata_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceFetchMetadataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceFetchMetadataResult {
  result_value: Option<TSFetchMetadataResp>,
}

impl IClientRPCServiceFetchMetadataResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceFetchMetadataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSFetchMetadataResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSFetchMetadataResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceFetchMetadataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceFetchMetadataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSFetchMetadataResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceFetchMetadata"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceCancelOperationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceCancelOperationArgs {
  req: TSCancelOperationReq,
}

impl IClientRPCServiceCancelOperationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceCancelOperationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSCancelOperationReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSCancelOperationReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceCancelOperationArgs.req", &f_1)?;
    let ret = IClientRPCServiceCancelOperationArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("cancelOperation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceCancelOperationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceCancelOperationResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceCancelOperationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceCancelOperationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceCancelOperationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceCancelOperationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceCancelOperation"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceCloseOperationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceCloseOperationArgs {
  req: TSCloseOperationReq,
}

impl IClientRPCServiceCloseOperationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceCloseOperationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSCloseOperationReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSCloseOperationReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceCloseOperationArgs.req", &f_1)?;
    let ret = IClientRPCServiceCloseOperationArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("closeOperation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceCloseOperationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceCloseOperationResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceCloseOperationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceCloseOperationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceCloseOperationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceCloseOperationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceCloseOperation"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceGetTimeZoneArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceGetTimeZoneArgs {
  session_id: i64,
}

impl IClientRPCServiceGetTimeZoneArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceGetTimeZoneArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceGetTimeZoneArgs.session_id", &f_1)?;
    let ret = IClientRPCServiceGetTimeZoneArgs {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getTimeZone_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceGetTimeZoneResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceGetTimeZoneResult {
  result_value: Option<TSGetTimeZoneResp>,
}

impl IClientRPCServiceGetTimeZoneResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceGetTimeZoneResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSGetTimeZoneResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSGetTimeZoneResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceGetTimeZoneResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceGetTimeZoneResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSGetTimeZoneResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceGetTimeZone"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceSetTimeZoneArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceSetTimeZoneArgs {
  req: TSSetTimeZoneReq,
}

impl IClientRPCServiceSetTimeZoneArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceSetTimeZoneArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSSetTimeZoneReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSSetTimeZoneReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceSetTimeZoneArgs.req", &f_1)?;
    let ret = IClientRPCServiceSetTimeZoneArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("setTimeZone_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceSetTimeZoneResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceSetTimeZoneResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceSetTimeZoneResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceSetTimeZoneResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceSetTimeZoneResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceSetTimeZoneResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceSetTimeZone"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceGetPropertiesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceGetPropertiesArgs {
}

impl IClientRPCServiceGetPropertiesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceGetPropertiesArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceGetPropertiesArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getProperties_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceGetPropertiesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceGetPropertiesResult {
  result_value: Option<ServerProperties>,
}

impl IClientRPCServiceGetPropertiesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceGetPropertiesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ServerProperties> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ServerProperties::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceGetPropertiesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceGetPropertiesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ServerProperties> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceGetProperties"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceSetStorageGroupArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceSetStorageGroupArgs {
  session_id: i64,
  storage_group: String,
}

impl IClientRPCServiceSetStorageGroupArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceSetStorageGroupArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceSetStorageGroupArgs.session_id", &f_1)?;
    verify_required_field_exists("IClientRPCServiceSetStorageGroupArgs.storage_group", &f_2)?;
    let ret = IClientRPCServiceSetStorageGroupArgs {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      storage_group: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("setStorageGroup_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("storageGroup", TType::String, 2))?;
    o_prot.write_string(&self.storage_group)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceSetStorageGroupResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceSetStorageGroupResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceSetStorageGroupResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceSetStorageGroupResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceSetStorageGroupResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceSetStorageGroupResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceSetStorageGroup"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceCreateTimeseriesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceCreateTimeseriesArgs {
  req: TSCreateTimeseriesReq,
}

impl IClientRPCServiceCreateTimeseriesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceCreateTimeseriesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSCreateTimeseriesReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSCreateTimeseriesReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceCreateTimeseriesArgs.req", &f_1)?;
    let ret = IClientRPCServiceCreateTimeseriesArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("createTimeseries_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceCreateTimeseriesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceCreateTimeseriesResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceCreateTimeseriesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceCreateTimeseriesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceCreateTimeseriesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceCreateTimeseriesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceCreateTimeseries"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceCreateAlignedTimeseriesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceCreateAlignedTimeseriesArgs {
  req: TSCreateAlignedTimeseriesReq,
}

impl IClientRPCServiceCreateAlignedTimeseriesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceCreateAlignedTimeseriesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSCreateAlignedTimeseriesReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSCreateAlignedTimeseriesReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceCreateAlignedTimeseriesArgs.req", &f_1)?;
    let ret = IClientRPCServiceCreateAlignedTimeseriesArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("createAlignedTimeseries_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceCreateAlignedTimeseriesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceCreateAlignedTimeseriesResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceCreateAlignedTimeseriesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceCreateAlignedTimeseriesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceCreateAlignedTimeseriesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceCreateAlignedTimeseriesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceCreateAlignedTimeseries"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceCreateMultiTimeseriesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceCreateMultiTimeseriesArgs {
  req: TSCreateMultiTimeseriesReq,
}

impl IClientRPCServiceCreateMultiTimeseriesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceCreateMultiTimeseriesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSCreateMultiTimeseriesReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSCreateMultiTimeseriesReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceCreateMultiTimeseriesArgs.req", &f_1)?;
    let ret = IClientRPCServiceCreateMultiTimeseriesArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("createMultiTimeseries_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceCreateMultiTimeseriesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceCreateMultiTimeseriesResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceCreateMultiTimeseriesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceCreateMultiTimeseriesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceCreateMultiTimeseriesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceCreateMultiTimeseriesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceCreateMultiTimeseries"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceDeleteTimeseriesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceDeleteTimeseriesArgs {
  session_id: i64,
  path: Vec<String>,
}

impl IClientRPCServiceDeleteTimeseriesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceDeleteTimeseriesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_91 = i_prot.read_string()?;
            val.push(list_elem_91);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceDeleteTimeseriesArgs.session_id", &f_1)?;
    verify_required_field_exists("IClientRPCServiceDeleteTimeseriesArgs.path", &f_2)?;
    let ret = IClientRPCServiceDeleteTimeseriesArgs {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      path: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("deleteTimeseries_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("path", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.path.len() as i32))?;
    for e in &self.path {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceDeleteTimeseriesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceDeleteTimeseriesResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceDeleteTimeseriesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceDeleteTimeseriesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceDeleteTimeseriesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceDeleteTimeseriesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceDeleteTimeseries"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceDeleteStorageGroupsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceDeleteStorageGroupsArgs {
  session_id: i64,
  storage_group: Vec<String>,
}

impl IClientRPCServiceDeleteStorageGroupsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceDeleteStorageGroupsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_92 = i_prot.read_string()?;
            val.push(list_elem_92);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceDeleteStorageGroupsArgs.session_id", &f_1)?;
    verify_required_field_exists("IClientRPCServiceDeleteStorageGroupsArgs.storage_group", &f_2)?;
    let ret = IClientRPCServiceDeleteStorageGroupsArgs {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      storage_group: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("deleteStorageGroups_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("storageGroup", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.storage_group.len() as i32))?;
    for e in &self.storage_group {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceDeleteStorageGroupsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceDeleteStorageGroupsResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceDeleteStorageGroupsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceDeleteStorageGroupsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceDeleteStorageGroupsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceDeleteStorageGroupsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceDeleteStorageGroups"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceInsertRecordArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceInsertRecordArgs {
  req: TSInsertRecordReq,
}

impl IClientRPCServiceInsertRecordArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceInsertRecordArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertRecordReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertRecordReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceInsertRecordArgs.req", &f_1)?;
    let ret = IClientRPCServiceInsertRecordArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("insertRecord_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceInsertRecordResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceInsertRecordResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceInsertRecordResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceInsertRecordResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceInsertRecordResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceInsertRecordResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceInsertRecord"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceInsertStringRecordArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceInsertStringRecordArgs {
  req: TSInsertStringRecordReq,
}

impl IClientRPCServiceInsertStringRecordArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceInsertStringRecordArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertStringRecordReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertStringRecordReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceInsertStringRecordArgs.req", &f_1)?;
    let ret = IClientRPCServiceInsertStringRecordArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("insertStringRecord_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceInsertStringRecordResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceInsertStringRecordResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceInsertStringRecordResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceInsertStringRecordResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceInsertStringRecordResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceInsertStringRecordResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceInsertStringRecord"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceInsertTabletArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceInsertTabletArgs {
  req: TSInsertTabletReq,
}

impl IClientRPCServiceInsertTabletArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceInsertTabletArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertTabletReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertTabletReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceInsertTabletArgs.req", &f_1)?;
    let ret = IClientRPCServiceInsertTabletArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("insertTablet_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceInsertTabletResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceInsertTabletResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceInsertTabletResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceInsertTabletResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceInsertTabletResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceInsertTabletResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceInsertTablet"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceInsertTabletsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceInsertTabletsArgs {
  req: TSInsertTabletsReq,
}

impl IClientRPCServiceInsertTabletsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceInsertTabletsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertTabletsReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertTabletsReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceInsertTabletsArgs.req", &f_1)?;
    let ret = IClientRPCServiceInsertTabletsArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("insertTablets_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceInsertTabletsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceInsertTabletsResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceInsertTabletsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceInsertTabletsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceInsertTabletsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceInsertTabletsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceInsertTablets"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceInsertRecordsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceInsertRecordsArgs {
  req: TSInsertRecordsReq,
}

impl IClientRPCServiceInsertRecordsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceInsertRecordsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertRecordsReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertRecordsReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceInsertRecordsArgs.req", &f_1)?;
    let ret = IClientRPCServiceInsertRecordsArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("insertRecords_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceInsertRecordsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceInsertRecordsResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceInsertRecordsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceInsertRecordsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceInsertRecordsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceInsertRecordsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceInsertRecords"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceInsertRecordsOfOneDeviceArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceInsertRecordsOfOneDeviceArgs {
  req: TSInsertRecordsOfOneDeviceReq,
}

impl IClientRPCServiceInsertRecordsOfOneDeviceArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceInsertRecordsOfOneDeviceArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertRecordsOfOneDeviceReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertRecordsOfOneDeviceReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceInsertRecordsOfOneDeviceArgs.req", &f_1)?;
    let ret = IClientRPCServiceInsertRecordsOfOneDeviceArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("insertRecordsOfOneDevice_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceInsertRecordsOfOneDeviceResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceInsertRecordsOfOneDeviceResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceInsertRecordsOfOneDeviceResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceInsertRecordsOfOneDeviceResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceInsertRecordsOfOneDeviceResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceInsertRecordsOfOneDeviceResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceInsertRecordsOfOneDevice"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceInsertStringRecordsOfOneDeviceArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceInsertStringRecordsOfOneDeviceArgs {
  req: TSInsertStringRecordsOfOneDeviceReq,
}

impl IClientRPCServiceInsertStringRecordsOfOneDeviceArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceInsertStringRecordsOfOneDeviceArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertStringRecordsOfOneDeviceReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertStringRecordsOfOneDeviceReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceInsertStringRecordsOfOneDeviceArgs.req", &f_1)?;
    let ret = IClientRPCServiceInsertStringRecordsOfOneDeviceArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("insertStringRecordsOfOneDevice_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceInsertStringRecordsOfOneDeviceResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceInsertStringRecordsOfOneDeviceResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceInsertStringRecordsOfOneDeviceResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceInsertStringRecordsOfOneDeviceResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceInsertStringRecordsOfOneDeviceResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceInsertStringRecordsOfOneDeviceResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceInsertStringRecordsOfOneDevice"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceInsertStringRecordsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceInsertStringRecordsArgs {
  req: TSInsertStringRecordsReq,
}

impl IClientRPCServiceInsertStringRecordsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceInsertStringRecordsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertStringRecordsReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertStringRecordsReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceInsertStringRecordsArgs.req", &f_1)?;
    let ret = IClientRPCServiceInsertStringRecordsArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("insertStringRecords_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceInsertStringRecordsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceInsertStringRecordsResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceInsertStringRecordsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceInsertStringRecordsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceInsertStringRecordsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceInsertStringRecordsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceInsertStringRecords"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceTestInsertTabletArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceTestInsertTabletArgs {
  req: TSInsertTabletReq,
}

impl IClientRPCServiceTestInsertTabletArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceTestInsertTabletArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertTabletReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertTabletReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceTestInsertTabletArgs.req", &f_1)?;
    let ret = IClientRPCServiceTestInsertTabletArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("testInsertTablet_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceTestInsertTabletResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceTestInsertTabletResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceTestInsertTabletResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceTestInsertTabletResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceTestInsertTabletResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceTestInsertTabletResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceTestInsertTablet"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceTestInsertTabletsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceTestInsertTabletsArgs {
  req: TSInsertTabletsReq,
}

impl IClientRPCServiceTestInsertTabletsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceTestInsertTabletsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertTabletsReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertTabletsReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceTestInsertTabletsArgs.req", &f_1)?;
    let ret = IClientRPCServiceTestInsertTabletsArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("testInsertTablets_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceTestInsertTabletsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceTestInsertTabletsResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceTestInsertTabletsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceTestInsertTabletsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceTestInsertTabletsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceTestInsertTabletsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceTestInsertTablets"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceTestInsertRecordArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceTestInsertRecordArgs {
  req: TSInsertRecordReq,
}

impl IClientRPCServiceTestInsertRecordArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceTestInsertRecordArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertRecordReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertRecordReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceTestInsertRecordArgs.req", &f_1)?;
    let ret = IClientRPCServiceTestInsertRecordArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("testInsertRecord_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceTestInsertRecordResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceTestInsertRecordResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceTestInsertRecordResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceTestInsertRecordResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceTestInsertRecordResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceTestInsertRecordResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceTestInsertRecord"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceTestInsertStringRecordArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceTestInsertStringRecordArgs {
  req: TSInsertStringRecordReq,
}

impl IClientRPCServiceTestInsertStringRecordArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceTestInsertStringRecordArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertStringRecordReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertStringRecordReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceTestInsertStringRecordArgs.req", &f_1)?;
    let ret = IClientRPCServiceTestInsertStringRecordArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("testInsertStringRecord_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceTestInsertStringRecordResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceTestInsertStringRecordResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceTestInsertStringRecordResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceTestInsertStringRecordResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceTestInsertStringRecordResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceTestInsertStringRecordResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceTestInsertStringRecord"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceTestInsertRecordsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceTestInsertRecordsArgs {
  req: TSInsertRecordsReq,
}

impl IClientRPCServiceTestInsertRecordsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceTestInsertRecordsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertRecordsReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertRecordsReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceTestInsertRecordsArgs.req", &f_1)?;
    let ret = IClientRPCServiceTestInsertRecordsArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("testInsertRecords_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceTestInsertRecordsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceTestInsertRecordsResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceTestInsertRecordsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceTestInsertRecordsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceTestInsertRecordsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceTestInsertRecordsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceTestInsertRecords"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceTestInsertRecordsOfOneDeviceArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceTestInsertRecordsOfOneDeviceArgs {
  req: TSInsertRecordsOfOneDeviceReq,
}

impl IClientRPCServiceTestInsertRecordsOfOneDeviceArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceTestInsertRecordsOfOneDeviceArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertRecordsOfOneDeviceReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertRecordsOfOneDeviceReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceTestInsertRecordsOfOneDeviceArgs.req", &f_1)?;
    let ret = IClientRPCServiceTestInsertRecordsOfOneDeviceArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("testInsertRecordsOfOneDevice_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceTestInsertRecordsOfOneDeviceResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceTestInsertRecordsOfOneDeviceResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceTestInsertRecordsOfOneDeviceResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceTestInsertRecordsOfOneDeviceResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceTestInsertRecordsOfOneDeviceResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceTestInsertRecordsOfOneDeviceResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceTestInsertRecordsOfOneDevice"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceTestInsertStringRecordsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceTestInsertStringRecordsArgs {
  req: TSInsertStringRecordsReq,
}

impl IClientRPCServiceTestInsertStringRecordsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceTestInsertStringRecordsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertStringRecordsReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertStringRecordsReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceTestInsertStringRecordsArgs.req", &f_1)?;
    let ret = IClientRPCServiceTestInsertStringRecordsArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("testInsertStringRecords_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceTestInsertStringRecordsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceTestInsertStringRecordsResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceTestInsertStringRecordsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceTestInsertStringRecordsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceTestInsertStringRecordsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceTestInsertStringRecordsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceTestInsertStringRecords"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceDeleteDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceDeleteDataArgs {
  req: TSDeleteDataReq,
}

impl IClientRPCServiceDeleteDataArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceDeleteDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSDeleteDataReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSDeleteDataReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceDeleteDataArgs.req", &f_1)?;
    let ret = IClientRPCServiceDeleteDataArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("deleteData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceDeleteDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceDeleteDataResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceDeleteDataResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceDeleteDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceDeleteDataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceDeleteDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceDeleteData"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceExecuteRawDataQueryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceExecuteRawDataQueryArgs {
  req: TSRawDataQueryReq,
}

impl IClientRPCServiceExecuteRawDataQueryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceExecuteRawDataQueryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSRawDataQueryReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSRawDataQueryReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceExecuteRawDataQueryArgs.req", &f_1)?;
    let ret = IClientRPCServiceExecuteRawDataQueryArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("executeRawDataQuery_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceExecuteRawDataQueryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceExecuteRawDataQueryResult {
  result_value: Option<TSExecuteStatementResp>,
}

impl IClientRPCServiceExecuteRawDataQueryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceExecuteRawDataQueryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSExecuteStatementResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSExecuteStatementResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceExecuteRawDataQueryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceExecuteRawDataQueryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSExecuteStatementResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceExecuteRawDataQuery"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceExecuteLastDataQueryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceExecuteLastDataQueryArgs {
  req: TSLastDataQueryReq,
}

impl IClientRPCServiceExecuteLastDataQueryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceExecuteLastDataQueryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSLastDataQueryReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSLastDataQueryReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceExecuteLastDataQueryArgs.req", &f_1)?;
    let ret = IClientRPCServiceExecuteLastDataQueryArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("executeLastDataQuery_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceExecuteLastDataQueryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceExecuteLastDataQueryResult {
  result_value: Option<TSExecuteStatementResp>,
}

impl IClientRPCServiceExecuteLastDataQueryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceExecuteLastDataQueryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSExecuteStatementResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSExecuteStatementResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceExecuteLastDataQueryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceExecuteLastDataQueryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSExecuteStatementResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceExecuteLastDataQuery"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceRequestStatementIdArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceRequestStatementIdArgs {
  session_id: i64,
}

impl IClientRPCServiceRequestStatementIdArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceRequestStatementIdArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceRequestStatementIdArgs.session_id", &f_1)?;
    let ret = IClientRPCServiceRequestStatementIdArgs {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("requestStatementId_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceRequestStatementIdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceRequestStatementIdResult {
  result_value: Option<i64>,
}

impl IClientRPCServiceRequestStatementIdResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceRequestStatementIdResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceRequestStatementIdResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceRequestStatementIdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceRequestStatementId"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceCreateSchemaTemplateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceCreateSchemaTemplateArgs {
  req: TSCreateSchemaTemplateReq,
}

impl IClientRPCServiceCreateSchemaTemplateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceCreateSchemaTemplateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSCreateSchemaTemplateReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSCreateSchemaTemplateReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceCreateSchemaTemplateArgs.req", &f_1)?;
    let ret = IClientRPCServiceCreateSchemaTemplateArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("createSchemaTemplate_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceCreateSchemaTemplateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceCreateSchemaTemplateResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceCreateSchemaTemplateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceCreateSchemaTemplateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceCreateSchemaTemplateResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceCreateSchemaTemplateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceCreateSchemaTemplate"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceAppendSchemaTemplateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceAppendSchemaTemplateArgs {
  req: TSAppendSchemaTemplateReq,
}

impl IClientRPCServiceAppendSchemaTemplateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceAppendSchemaTemplateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSAppendSchemaTemplateReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSAppendSchemaTemplateReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceAppendSchemaTemplateArgs.req", &f_1)?;
    let ret = IClientRPCServiceAppendSchemaTemplateArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("appendSchemaTemplate_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceAppendSchemaTemplateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceAppendSchemaTemplateResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceAppendSchemaTemplateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceAppendSchemaTemplateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceAppendSchemaTemplateResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceAppendSchemaTemplateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceAppendSchemaTemplate"
          )
        )
      )
    }
  }
}

//
// IClientRPCServicePruneSchemaTemplateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServicePruneSchemaTemplateArgs {
  req: TSPruneSchemaTemplateReq,
}

impl IClientRPCServicePruneSchemaTemplateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServicePruneSchemaTemplateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSPruneSchemaTemplateReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSPruneSchemaTemplateReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServicePruneSchemaTemplateArgs.req", &f_1)?;
    let ret = IClientRPCServicePruneSchemaTemplateArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("pruneSchemaTemplate_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServicePruneSchemaTemplateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServicePruneSchemaTemplateResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServicePruneSchemaTemplateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServicePruneSchemaTemplateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServicePruneSchemaTemplateResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServicePruneSchemaTemplateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServicePruneSchemaTemplate"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceQuerySchemaTemplateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceQuerySchemaTemplateArgs {
  req: TSQueryTemplateReq,
}

impl IClientRPCServiceQuerySchemaTemplateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceQuerySchemaTemplateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSQueryTemplateReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSQueryTemplateReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceQuerySchemaTemplateArgs.req", &f_1)?;
    let ret = IClientRPCServiceQuerySchemaTemplateArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("querySchemaTemplate_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceQuerySchemaTemplateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceQuerySchemaTemplateResult {
  result_value: Option<TSQueryTemplateResp>,
}

impl IClientRPCServiceQuerySchemaTemplateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceQuerySchemaTemplateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSQueryTemplateResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSQueryTemplateResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceQuerySchemaTemplateResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceQuerySchemaTemplateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSQueryTemplateResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceQuerySchemaTemplate"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceSetSchemaTemplateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceSetSchemaTemplateArgs {
  req: TSSetSchemaTemplateReq,
}

impl IClientRPCServiceSetSchemaTemplateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceSetSchemaTemplateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSSetSchemaTemplateReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSSetSchemaTemplateReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceSetSchemaTemplateArgs.req", &f_1)?;
    let ret = IClientRPCServiceSetSchemaTemplateArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("setSchemaTemplate_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceSetSchemaTemplateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceSetSchemaTemplateResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceSetSchemaTemplateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceSetSchemaTemplateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceSetSchemaTemplateResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceSetSchemaTemplateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceSetSchemaTemplate"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceUnsetSchemaTemplateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceUnsetSchemaTemplateArgs {
  req: TSUnsetSchemaTemplateReq,
}

impl IClientRPCServiceUnsetSchemaTemplateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceUnsetSchemaTemplateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSUnsetSchemaTemplateReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSUnsetSchemaTemplateReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceUnsetSchemaTemplateArgs.req", &f_1)?;
    let ret = IClientRPCServiceUnsetSchemaTemplateArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("unsetSchemaTemplate_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceUnsetSchemaTemplateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceUnsetSchemaTemplateResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceUnsetSchemaTemplateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceUnsetSchemaTemplateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceUnsetSchemaTemplateResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceUnsetSchemaTemplateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceUnsetSchemaTemplate"
          )
        )
      )
    }
  }
}

//
// IClientRPCServiceDropSchemaTemplateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceDropSchemaTemplateArgs {
  req: TSDropSchemaTemplateReq,
}

impl IClientRPCServiceDropSchemaTemplateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceDropSchemaTemplateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSDropSchemaTemplateReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSDropSchemaTemplateReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("IClientRPCServiceDropSchemaTemplateArgs.req", &f_1)?;
    let ret = IClientRPCServiceDropSchemaTemplateArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("dropSchemaTemplate_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IClientRPCServiceDropSchemaTemplateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct IClientRPCServiceDropSchemaTemplateResult {
  result_value: Option<common::TSStatus>,
}

impl IClientRPCServiceDropSchemaTemplateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IClientRPCServiceDropSchemaTemplateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common::TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common::TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IClientRPCServiceDropSchemaTemplateResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IClientRPCServiceDropSchemaTemplateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common::TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for IClientRPCServiceDropSchemaTemplate"
          )
        )
      )
    }
  }
}

