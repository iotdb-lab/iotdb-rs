// Autogenerated by Thrift Compiler (0.15.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSProtocolVersion(pub i32);

impl TSProtocolVersion {
  pub const IOTDB_SERVICE_PROTOCOL_V1: TSProtocolVersion = TSProtocolVersion(0);
  pub const IOTDB_SERVICE_PROTOCOL_V2: TSProtocolVersion = TSProtocolVersion(1);
  pub const IOTDB_SERVICE_PROTOCOL_V3: TSProtocolVersion = TSProtocolVersion(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::IOTDB_SERVICE_PROTOCOL_V1,
    Self::IOTDB_SERVICE_PROTOCOL_V2,
    Self::IOTDB_SERVICE_PROTOCOL_V3,
  ];
  #[allow(clippy::trivially_copy_pass_by_ref)]
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSProtocolVersion> {
    let enum_value = i_prot.read_i32()?;
    Ok(TSProtocolVersion::from(enum_value))
  }
}

impl From<i32> for TSProtocolVersion {
  fn from(i: i32) -> Self {
    match i {
      0 => TSProtocolVersion::IOTDB_SERVICE_PROTOCOL_V1,
      1 => TSProtocolVersion::IOTDB_SERVICE_PROTOCOL_V2,
      2 => TSProtocolVersion::IOTDB_SERVICE_PROTOCOL_V3,
      _ => TSProtocolVersion(i)
    }
  }
}

impl From<&i32> for TSProtocolVersion {
  fn from(i: &i32) -> Self {
    TSProtocolVersion::from(*i)
  }
}

impl From<TSProtocolVersion> for i32 {
  fn from(e: TSProtocolVersion) -> i32 {
    e.0
  }
}

impl From<&TSProtocolVersion> for i32 {
  fn from(e: &TSProtocolVersion) -> i32 {
    e.0
  }
}

//
// EndPoint
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct EndPoint {
  pub ip: String,
  pub port: i32,
}

impl EndPoint {
  pub fn new(ip: String, port: i32) -> EndPoint {
    EndPoint {
      ip,
      port,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<EndPoint> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("EndPoint.ip", &f_1)?;
    verify_required_field_exists("EndPoint.port", &f_2)?;
    let ret = EndPoint {
      ip: f_1.expect("auto-generated code should have checked for presence of required fields"),
      port: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("EndPoint");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ip", TType::String, 1))?;
    o_prot.write_string(&self.ip)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("port", TType::I32, 2))?;
    o_prot.write_i32(self.port)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSStatus
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSStatus {
  pub code: i32,
  pub message: Option<String>,
  pub sub_status: Option<Vec<Box<TSStatus>>>,
  pub redirect_node: Option<EndPoint>,
}

impl TSStatus {
  pub fn new<F2, F3, F4>(code: i32, message: F2, sub_status: F3, redirect_node: F4) -> TSStatus where F2: Into<Option<String>>, F3: Into<Option<Vec<Box<TSStatus>>>>, F4: Into<Option<EndPoint>> {
    TSStatus {
      code,
      message: message.into(),
      sub_status: sub_status.into(),
      redirect_node: redirect_node.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSStatus> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<Box<TSStatus>>> = None;
    let mut f_4: Option<EndPoint> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<TSStatus>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = Box::new(TSStatus::read_from_in_protocol(i_prot)?);
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = EndPoint::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSStatus.code", &f_1)?;
    let ret = TSStatus {
      code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      message: f_2,
      sub_status: f_3,
      redirect_node: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSStatus");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::I32, 1))?;
    o_prot.write_i32(self.code)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sub_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("subStatus", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.redirect_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("redirectNode", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSQueryDataSet
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSQueryDataSet {
  pub time: Vec<u8>,
  pub value_list: Vec<Vec<u8>>,
  pub bitmap_list: Vec<Vec<u8>>,
}

impl TSQueryDataSet {
  pub fn new(time: Vec<u8>, value_list: Vec<Vec<u8>>, bitmap_list: Vec<Vec<u8>>) -> TSQueryDataSet {
    TSQueryDataSet {
      time,
      value_list,
      bitmap_list,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSQueryDataSet> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = None;
    let mut f_2: Option<Vec<Vec<u8>>> = None;
    let mut f_3: Option<Vec<Vec<u8>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = i_prot.read_bytes()?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = i_prot.read_bytes()?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSQueryDataSet.time", &f_1)?;
    verify_required_field_exists("TSQueryDataSet.value_list", &f_2)?;
    verify_required_field_exists("TSQueryDataSet.bitmap_list", &f_3)?;
    let ret = TSQueryDataSet {
      time: f_1.expect("auto-generated code should have checked for presence of required fields"),
      value_list: f_2.expect("auto-generated code should have checked for presence of required fields"),
      bitmap_list: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSQueryDataSet");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("time", TType::String, 1))?;
    o_prot.write_bytes(&self.time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("valueList", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.value_list.len() as i32))?;
    for e in &self.value_list {
      o_prot.write_bytes(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("bitmapList", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.bitmap_list.len() as i32))?;
    for e in &self.bitmap_list {
      o_prot.write_bytes(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSQueryNonAlignDataSet
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSQueryNonAlignDataSet {
  pub time_list: Vec<Vec<u8>>,
  pub value_list: Vec<Vec<u8>>,
}

impl TSQueryNonAlignDataSet {
  pub fn new(time_list: Vec<Vec<u8>>, value_list: Vec<Vec<u8>>) -> TSQueryNonAlignDataSet {
    TSQueryNonAlignDataSet {
      time_list,
      value_list,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSQueryNonAlignDataSet> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<Vec<u8>>> = None;
    let mut f_2: Option<Vec<Vec<u8>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = i_prot.read_bytes()?;
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = i_prot.read_bytes()?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSQueryNonAlignDataSet.time_list", &f_1)?;
    verify_required_field_exists("TSQueryNonAlignDataSet.value_list", &f_2)?;
    let ret = TSQueryNonAlignDataSet {
      time_list: f_1.expect("auto-generated code should have checked for presence of required fields"),
      value_list: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSQueryNonAlignDataSet");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timeList", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.time_list.len() as i32))?;
    for e in &self.time_list {
      o_prot.write_bytes(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("valueList", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.value_list.len() as i32))?;
    for e in &self.value_list {
      o_prot.write_bytes(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSTracingInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSTracingInfo {
  pub activity_list: Vec<String>,
  pub elapsed_time_list: Vec<i64>,
  pub series_path_num: Option<i32>,
  pub seq_file_num: Option<i32>,
  pub un_seq_file_num: Option<i32>,
  pub sequence_chunk_num: Option<i32>,
  pub sequence_chunk_point_num: Option<i64>,
  pub unsequence_chunk_num: Option<i32>,
  pub unsequence_chunk_point_num: Option<i64>,
  pub total_page_num: Option<i32>,
  pub overlapped_page_num: Option<i32>,
}

impl TSTracingInfo {
  pub fn new<F3, F4, F5, F6, F7, F8, F9, F10, F11>(activity_list: Vec<String>, elapsed_time_list: Vec<i64>, series_path_num: F3, seq_file_num: F4, un_seq_file_num: F5, sequence_chunk_num: F6, sequence_chunk_point_num: F7, unsequence_chunk_num: F8, unsequence_chunk_point_num: F9, total_page_num: F10, overlapped_page_num: F11) -> TSTracingInfo where F3: Into<Option<i32>>, F4: Into<Option<i32>>, F5: Into<Option<i32>>, F6: Into<Option<i32>>, F7: Into<Option<i64>>, F8: Into<Option<i32>>, F9: Into<Option<i64>>, F10: Into<Option<i32>>, F11: Into<Option<i32>> {
    TSTracingInfo {
      activity_list,
      elapsed_time_list,
      series_path_num: series_path_num.into(),
      seq_file_num: seq_file_num.into(),
      un_seq_file_num: un_seq_file_num.into(),
      sequence_chunk_num: sequence_chunk_num.into(),
      sequence_chunk_point_num: sequence_chunk_point_num.into(),
      unsequence_chunk_num: unsequence_chunk_num.into(),
      unsequence_chunk_point_num: unsequence_chunk_point_num.into(),
      total_page_num: total_page_num.into(),
      overlapped_page_num: overlapped_page_num.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSTracingInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<Vec<i64>> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i32> = None;
    let mut f_7: Option<i64> = None;
    let mut f_8: Option<i32> = None;
    let mut f_9: Option<i64> = None;
    let mut f_10: Option<i32> = None;
    let mut f_11: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_5 = i_prot.read_string()?;
            val.push(list_elem_5);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_6 = i_prot.read_i64()?;
            val.push(list_elem_6);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i64()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i32()?;
          f_11 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSTracingInfo.activity_list", &f_1)?;
    verify_required_field_exists("TSTracingInfo.elapsed_time_list", &f_2)?;
    let ret = TSTracingInfo {
      activity_list: f_1.expect("auto-generated code should have checked for presence of required fields"),
      elapsed_time_list: f_2.expect("auto-generated code should have checked for presence of required fields"),
      series_path_num: f_3,
      seq_file_num: f_4,
      un_seq_file_num: f_5,
      sequence_chunk_num: f_6,
      sequence_chunk_point_num: f_7,
      unsequence_chunk_num: f_8,
      unsequence_chunk_point_num: f_9,
      total_page_num: f_10,
      overlapped_page_num: f_11,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSTracingInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("activityList", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.activity_list.len() as i32))?;
    for e in &self.activity_list {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("elapsedTimeList", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.elapsed_time_list.len() as i32))?;
    for e in &self.elapsed_time_list {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.series_path_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("seriesPathNum", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.seq_file_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("seqFileNum", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.un_seq_file_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("unSeqFileNum", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.sequence_chunk_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("sequenceChunkNum", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.sequence_chunk_point_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("sequenceChunkPointNum", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.unsequence_chunk_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("unsequenceChunkNum", TType::I32, 8))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.unsequence_chunk_point_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("unsequenceChunkPointNum", TType::I64, 9))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.total_page_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("totalPageNum", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.overlapped_page_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("overlappedPageNum", TType::I32, 11))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSExecuteStatementResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSExecuteStatementResp {
  pub status: TSStatus,
  pub query_id: Option<i64>,
  pub columns: Option<Vec<String>>,
  pub operation_type: Option<String>,
  pub ignore_time_stamp: Option<bool>,
  pub data_type_list: Option<Vec<String>>,
  pub query_data_set: Option<TSQueryDataSet>,
  pub non_align_query_data_set: Option<TSQueryNonAlignDataSet>,
  pub column_name_index_map: Option<BTreeMap<String, i32>>,
  pub sg_columns: Option<Vec<String>>,
  pub alias_columns: Option<Vec<i8>>,
  pub tracing_info: Option<TSTracingInfo>,
}

impl TSExecuteStatementResp {
  pub fn new<F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12>(status: TSStatus, query_id: F2, columns: F3, operation_type: F4, ignore_time_stamp: F5, data_type_list: F6, query_data_set: F7, non_align_query_data_set: F8, column_name_index_map: F9, sg_columns: F10, alias_columns: F11, tracing_info: F12) -> TSExecuteStatementResp where F2: Into<Option<i64>>, F3: Into<Option<Vec<String>>>, F4: Into<Option<String>>, F5: Into<Option<bool>>, F6: Into<Option<Vec<String>>>, F7: Into<Option<TSQueryDataSet>>, F8: Into<Option<TSQueryNonAlignDataSet>>, F9: Into<Option<BTreeMap<String, i32>>>, F10: Into<Option<Vec<String>>>, F11: Into<Option<Vec<i8>>>, F12: Into<Option<TSTracingInfo>> {
    TSExecuteStatementResp {
      status,
      query_id: query_id.into(),
      columns: columns.into(),
      operation_type: operation_type.into(),
      ignore_time_stamp: ignore_time_stamp.into(),
      data_type_list: data_type_list.into(),
      query_data_set: query_data_set.into(),
      non_align_query_data_set: non_align_query_data_set.into(),
      column_name_index_map: column_name_index_map.into(),
      sg_columns: sg_columns.into(),
      alias_columns: alias_columns.into(),
      tracing_info: tracing_info.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSExecuteStatementResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSStatus> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<Vec<String>> = None;
    let mut f_7: Option<TSQueryDataSet> = None;
    let mut f_8: Option<TSQueryNonAlignDataSet> = None;
    let mut f_9: Option<BTreeMap<String, i32>> = None;
    let mut f_10: Option<Vec<String>> = None;
    let mut f_11: Option<Vec<i8>> = None;
    let mut f_12: Option<TSTracingInfo> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_7 = i_prot.read_string()?;
            val.push(list_elem_7);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_8 = i_prot.read_string()?;
            val.push(list_elem_8);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let val = TSQueryDataSet::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = TSQueryNonAlignDataSet::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, i32> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_9 = i_prot.read_string()?;
            let map_val_10 = i_prot.read_i32()?;
            val.insert(map_key_9, map_val_10);
          }
          i_prot.read_map_end()?;
          f_9 = Some(val);
        },
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_11 = i_prot.read_string()?;
            val.push(list_elem_11);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        11 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i8> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_12 = i_prot.read_i8()?;
            val.push(list_elem_12);
          }
          i_prot.read_list_end()?;
          f_11 = Some(val);
        },
        12 => {
          let val = TSTracingInfo::read_from_in_protocol(i_prot)?;
          f_12 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSExecuteStatementResp.status", &f_1)?;
    let ret = TSExecuteStatementResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query_id: f_2,
      columns: f_3,
      operation_type: f_4,
      ignore_time_stamp: f_5,
      data_type_list: f_6,
      query_data_set: f_7,
      non_align_query_data_set: f_8,
      column_name_index_map: f_9,
      sg_columns: f_10,
      alias_columns: f_11,
      tracing_info: f_12,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSExecuteStatementResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.query_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryId", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("columns", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.operation_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("operationType", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ignore_time_stamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("ignoreTimeStamp", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.data_type_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("dataTypeList", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_data_set {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryDataSet", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.non_align_query_data_set {
      o_prot.write_field_begin(&TFieldIdentifier::new("nonAlignQueryDataSet", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.column_name_index_map {
      o_prot.write_field_begin(&TFieldIdentifier::new("columnNameIndexMap", TType::Map, 9))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::I32, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_i32(*v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sg_columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("sgColumns", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.alias_columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("aliasColumns", TType::List, 11))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I08, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i8(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tracing_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("tracingInfo", TType::Struct, 12))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSOpenSessionResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSOpenSessionResp {
  pub status: TSStatus,
  pub server_protocol_version: TSProtocolVersion,
  pub session_id: Option<i64>,
  pub configuration: Option<BTreeMap<String, String>>,
}

impl TSOpenSessionResp {
  pub fn new<F3, F4>(status: TSStatus, server_protocol_version: TSProtocolVersion, session_id: F3, configuration: F4) -> TSOpenSessionResp where F3: Into<Option<i64>>, F4: Into<Option<BTreeMap<String, String>>> {
    TSOpenSessionResp {
      status,
      server_protocol_version,
      session_id: session_id.into(),
      configuration: configuration.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSOpenSessionResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSStatus> = None;
    let mut f_2: Option<TSProtocolVersion> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = TSProtocolVersion::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_13 = i_prot.read_string()?;
            let map_val_14 = i_prot.read_string()?;
            val.insert(map_key_13, map_val_14);
          }
          i_prot.read_map_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSOpenSessionResp.status", &f_1)?;
    verify_required_field_exists("TSOpenSessionResp.server_protocol_version", &f_2)?;
    let ret = TSOpenSessionResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      server_protocol_version: f_2.expect("auto-generated code should have checked for presence of required fields"),
      session_id: f_3,
      configuration: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSOpenSessionResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("serverProtocolVersion", TType::I32, 2))?;
    self.server_protocol_version.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.session_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.configuration {
      o_prot.write_field_begin(&TFieldIdentifier::new("configuration", TType::Map, 4))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSOpenSessionReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSOpenSessionReq {
  pub client_protocol: TSProtocolVersion,
  pub zone_id: String,
  pub username: Option<String>,
  pub password: Option<String>,
  pub configuration: Option<BTreeMap<String, String>>,
}

impl TSOpenSessionReq {
  pub fn new<F3, F4, F5>(client_protocol: TSProtocolVersion, zone_id: String, username: F3, password: F4, configuration: F5) -> TSOpenSessionReq where F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<BTreeMap<String, String>>> {
    TSOpenSessionReq {
      client_protocol,
      zone_id,
      username: username.into(),
      password: password.into(),
      configuration: configuration.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSOpenSessionReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSProtocolVersion> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSProtocolVersion::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_15 = i_prot.read_string()?;
            let map_val_16 = i_prot.read_string()?;
            val.insert(map_key_15, map_val_16);
          }
          i_prot.read_map_end()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSOpenSessionReq.client_protocol", &f_1)?;
    verify_required_field_exists("TSOpenSessionReq.zone_id", &f_2)?;
    let ret = TSOpenSessionReq {
      client_protocol: f_1.expect("auto-generated code should have checked for presence of required fields"),
      zone_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      username: f_3,
      password: f_4,
      configuration: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSOpenSessionReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("client_protocol", TType::I32, 1))?;
    self.client_protocol.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("zoneId", TType::String, 2))?;
    o_prot.write_string(&self.zone_id)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.username {
      o_prot.write_field_begin(&TFieldIdentifier::new("username", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.password {
      o_prot.write_field_begin(&TFieldIdentifier::new("password", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.configuration {
      o_prot.write_field_begin(&TFieldIdentifier::new("configuration", TType::Map, 5))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSCloseSessionReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSCloseSessionReq {
  pub session_id: i64,
}

impl TSCloseSessionReq {
  pub fn new(session_id: i64) -> TSCloseSessionReq {
    TSCloseSessionReq {
      session_id,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSCloseSessionReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSCloseSessionReq.session_id", &f_1)?;
    let ret = TSCloseSessionReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSCloseSessionReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSExecuteStatementReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSExecuteStatementReq {
  pub session_id: i64,
  pub statement: String,
  pub statement_id: i64,
  pub fetch_size: Option<i32>,
  pub timeout: Option<i64>,
  pub enable_redirect_query: Option<bool>,
  pub jdbc_query: Option<bool>,
}

impl TSExecuteStatementReq {
  pub fn new<F4, F5, F6, F7>(session_id: i64, statement: String, statement_id: i64, fetch_size: F4, timeout: F5, enable_redirect_query: F6, jdbc_query: F7) -> TSExecuteStatementReq where F4: Into<Option<i32>>, F5: Into<Option<i64>>, F6: Into<Option<bool>>, F7: Into<Option<bool>> {
    TSExecuteStatementReq {
      session_id,
      statement,
      statement_id,
      fetch_size: fetch_size.into(),
      timeout: timeout.into(),
      enable_redirect_query: enable_redirect_query.into(),
      jdbc_query: jdbc_query.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSExecuteStatementReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSExecuteStatementReq.session_id", &f_1)?;
    verify_required_field_exists("TSExecuteStatementReq.statement", &f_2)?;
    verify_required_field_exists("TSExecuteStatementReq.statement_id", &f_3)?;
    let ret = TSExecuteStatementReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      statement: f_2.expect("auto-generated code should have checked for presence of required fields"),
      statement_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      fetch_size: f_4,
      timeout: f_5,
      enable_redirect_query: f_6,
      jdbc_query: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSExecuteStatementReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("statement", TType::String, 2))?;
    o_prot.write_string(&self.statement)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("statementId", TType::I64, 3))?;
    o_prot.write_i64(self.statement_id)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.fetch_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("fetchSize", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.timeout {
      o_prot.write_field_begin(&TFieldIdentifier::new("timeout", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.enable_redirect_query {
      o_prot.write_field_begin(&TFieldIdentifier::new("enableRedirectQuery", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.jdbc_query {
      o_prot.write_field_begin(&TFieldIdentifier::new("jdbcQuery", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSExecuteBatchStatementReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSExecuteBatchStatementReq {
  pub session_id: i64,
  pub statements: Vec<String>,
}

impl TSExecuteBatchStatementReq {
  pub fn new(session_id: i64, statements: Vec<String>) -> TSExecuteBatchStatementReq {
    TSExecuteBatchStatementReq {
      session_id,
      statements,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSExecuteBatchStatementReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_17 = i_prot.read_string()?;
            val.push(list_elem_17);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSExecuteBatchStatementReq.session_id", &f_1)?;
    verify_required_field_exists("TSExecuteBatchStatementReq.statements", &f_2)?;
    let ret = TSExecuteBatchStatementReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      statements: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSExecuteBatchStatementReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("statements", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.statements.len() as i32))?;
    for e in &self.statements {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSGetOperationStatusReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSGetOperationStatusReq {
  pub session_id: i64,
  pub query_id: i64,
}

impl TSGetOperationStatusReq {
  pub fn new(session_id: i64, query_id: i64) -> TSGetOperationStatusReq {
    TSGetOperationStatusReq {
      session_id,
      query_id,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSGetOperationStatusReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSGetOperationStatusReq.session_id", &f_1)?;
    verify_required_field_exists("TSGetOperationStatusReq.query_id", &f_2)?;
    let ret = TSGetOperationStatusReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSGetOperationStatusReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("queryId", TType::I64, 2))?;
    o_prot.write_i64(self.query_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSCancelOperationReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSCancelOperationReq {
  pub session_id: i64,
  pub query_id: i64,
}

impl TSCancelOperationReq {
  pub fn new(session_id: i64, query_id: i64) -> TSCancelOperationReq {
    TSCancelOperationReq {
      session_id,
      query_id,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSCancelOperationReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSCancelOperationReq.session_id", &f_1)?;
    verify_required_field_exists("TSCancelOperationReq.query_id", &f_2)?;
    let ret = TSCancelOperationReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSCancelOperationReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("queryId", TType::I64, 2))?;
    o_prot.write_i64(self.query_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSCloseOperationReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSCloseOperationReq {
  pub session_id: i64,
  pub query_id: Option<i64>,
  pub statement_id: Option<i64>,
}

impl TSCloseOperationReq {
  pub fn new<F2, F3>(session_id: i64, query_id: F2, statement_id: F3) -> TSCloseOperationReq where F2: Into<Option<i64>>, F3: Into<Option<i64>> {
    TSCloseOperationReq {
      session_id,
      query_id: query_id.into(),
      statement_id: statement_id.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSCloseOperationReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSCloseOperationReq.session_id", &f_1)?;
    let ret = TSCloseOperationReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      query_id: f_2,
      statement_id: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSCloseOperationReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.query_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryId", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.statement_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("statementId", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSFetchResultsReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSFetchResultsReq {
  pub session_id: i64,
  pub statement: String,
  pub fetch_size: i32,
  pub query_id: i64,
  pub is_align: bool,
  pub timeout: Option<i64>,
}

impl TSFetchResultsReq {
  pub fn new<F6>(session_id: i64, statement: String, fetch_size: i32, query_id: i64, is_align: bool, timeout: F6) -> TSFetchResultsReq where F6: Into<Option<i64>> {
    TSFetchResultsReq {
      session_id,
      statement,
      fetch_size,
      query_id,
      is_align,
      timeout: timeout.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSFetchResultsReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSFetchResultsReq.session_id", &f_1)?;
    verify_required_field_exists("TSFetchResultsReq.statement", &f_2)?;
    verify_required_field_exists("TSFetchResultsReq.fetch_size", &f_3)?;
    verify_required_field_exists("TSFetchResultsReq.query_id", &f_4)?;
    verify_required_field_exists("TSFetchResultsReq.is_align", &f_5)?;
    let ret = TSFetchResultsReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      statement: f_2.expect("auto-generated code should have checked for presence of required fields"),
      fetch_size: f_3.expect("auto-generated code should have checked for presence of required fields"),
      query_id: f_4.expect("auto-generated code should have checked for presence of required fields"),
      is_align: f_5.expect("auto-generated code should have checked for presence of required fields"),
      timeout: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSFetchResultsReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("statement", TType::String, 2))?;
    o_prot.write_string(&self.statement)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fetchSize", TType::I32, 3))?;
    o_prot.write_i32(self.fetch_size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("queryId", TType::I64, 4))?;
    o_prot.write_i64(self.query_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("isAlign", TType::Bool, 5))?;
    o_prot.write_bool(self.is_align)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.timeout {
      o_prot.write_field_begin(&TFieldIdentifier::new("timeout", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSFetchResultsResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSFetchResultsResp {
  pub status: TSStatus,
  pub has_result_set: bool,
  pub is_align: bool,
  pub query_data_set: Option<TSQueryDataSet>,
  pub non_align_query_data_set: Option<TSQueryNonAlignDataSet>,
}

impl TSFetchResultsResp {
  pub fn new<F4, F5>(status: TSStatus, has_result_set: bool, is_align: bool, query_data_set: F4, non_align_query_data_set: F5) -> TSFetchResultsResp where F4: Into<Option<TSQueryDataSet>>, F5: Into<Option<TSQueryNonAlignDataSet>> {
    TSFetchResultsResp {
      status,
      has_result_set,
      is_align,
      query_data_set: query_data_set.into(),
      non_align_query_data_set: non_align_query_data_set.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSFetchResultsResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSStatus> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<TSQueryDataSet> = None;
    let mut f_5: Option<TSQueryNonAlignDataSet> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = TSQueryDataSet::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = TSQueryNonAlignDataSet::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSFetchResultsResp.status", &f_1)?;
    verify_required_field_exists("TSFetchResultsResp.has_result_set", &f_2)?;
    verify_required_field_exists("TSFetchResultsResp.is_align", &f_3)?;
    let ret = TSFetchResultsResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      has_result_set: f_2.expect("auto-generated code should have checked for presence of required fields"),
      is_align: f_3.expect("auto-generated code should have checked for presence of required fields"),
      query_data_set: f_4,
      non_align_query_data_set: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSFetchResultsResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("hasResultSet", TType::Bool, 2))?;
    o_prot.write_bool(self.has_result_set)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("isAlign", TType::Bool, 3))?;
    o_prot.write_bool(self.is_align)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.query_data_set {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryDataSet", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.non_align_query_data_set {
      o_prot.write_field_begin(&TFieldIdentifier::new("nonAlignQueryDataSet", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSFetchMetadataResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSFetchMetadataResp {
  pub status: TSStatus,
  pub metadata_in_json: Option<String>,
  pub columns_list: Option<Vec<String>>,
  pub data_type: Option<String>,
}

impl TSFetchMetadataResp {
  pub fn new<F2, F3, F4>(status: TSStatus, metadata_in_json: F2, columns_list: F3, data_type: F4) -> TSFetchMetadataResp where F2: Into<Option<String>>, F3: Into<Option<Vec<String>>>, F4: Into<Option<String>> {
    TSFetchMetadataResp {
      status,
      metadata_in_json: metadata_in_json.into(),
      columns_list: columns_list.into(),
      data_type: data_type.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSFetchMetadataResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSStatus> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_18 = i_prot.read_string()?;
            val.push(list_elem_18);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSFetchMetadataResp.status", &f_1)?;
    let ret = TSFetchMetadataResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      metadata_in_json: f_2,
      columns_list: f_3,
      data_type: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSFetchMetadataResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.metadata_in_json {
      o_prot.write_field_begin(&TFieldIdentifier::new("metadataInJson", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.columns_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("columnsList", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.data_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("dataType", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSFetchMetadataReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSFetchMetadataReq {
  pub session_id: i64,
  pub type_: String,
  pub column_path: Option<String>,
}

impl TSFetchMetadataReq {
  pub fn new<F3>(session_id: i64, type_: String, column_path: F3) -> TSFetchMetadataReq where F3: Into<Option<String>> {
    TSFetchMetadataReq {
      session_id,
      type_,
      column_path: column_path.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSFetchMetadataReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSFetchMetadataReq.session_id", &f_1)?;
    verify_required_field_exists("TSFetchMetadataReq.type_", &f_2)?;
    let ret = TSFetchMetadataReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      type_: f_2.expect("auto-generated code should have checked for presence of required fields"),
      column_path: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSFetchMetadataReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::String, 2))?;
    o_prot.write_string(&self.type_)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.column_path {
      o_prot.write_field_begin(&TFieldIdentifier::new("columnPath", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSGetTimeZoneResp
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSGetTimeZoneResp {
  pub status: TSStatus,
  pub time_zone: String,
}

impl TSGetTimeZoneResp {
  pub fn new(status: TSStatus, time_zone: String) -> TSGetTimeZoneResp {
    TSGetTimeZoneResp {
      status,
      time_zone,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSGetTimeZoneResp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSStatus> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSGetTimeZoneResp.status", &f_1)?;
    verify_required_field_exists("TSGetTimeZoneResp.time_zone", &f_2)?;
    let ret = TSGetTimeZoneResp {
      status: f_1.expect("auto-generated code should have checked for presence of required fields"),
      time_zone: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSGetTimeZoneResp");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 1))?;
    self.status.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timeZone", TType::String, 2))?;
    o_prot.write_string(&self.time_zone)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSSetTimeZoneReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSSetTimeZoneReq {
  pub session_id: i64,
  pub time_zone: String,
}

impl TSSetTimeZoneReq {
  pub fn new(session_id: i64, time_zone: String) -> TSSetTimeZoneReq {
    TSSetTimeZoneReq {
      session_id,
      time_zone,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSSetTimeZoneReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSSetTimeZoneReq.session_id", &f_1)?;
    verify_required_field_exists("TSSetTimeZoneReq.time_zone", &f_2)?;
    let ret = TSSetTimeZoneReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      time_zone: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSSetTimeZoneReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timeZone", TType::String, 2))?;
    o_prot.write_string(&self.time_zone)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSInsertRecordReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSInsertRecordReq {
  pub session_id: i64,
  pub prefix_path: String,
  pub measurements: Vec<String>,
  pub values: Vec<u8>,
  pub timestamp: i64,
  pub is_aligned: Option<bool>,
}

impl TSInsertRecordReq {
  pub fn new<F6>(session_id: i64, prefix_path: String, measurements: Vec<String>, values: Vec<u8>, timestamp: i64, is_aligned: F6) -> TSInsertRecordReq where F6: Into<Option<bool>> {
    TSInsertRecordReq {
      session_id,
      prefix_path,
      measurements,
      values,
      timestamp,
      is_aligned: is_aligned.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSInsertRecordReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<u8>> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_19 = i_prot.read_string()?;
            val.push(list_elem_19);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSInsertRecordReq.session_id", &f_1)?;
    verify_required_field_exists("TSInsertRecordReq.prefix_path", &f_2)?;
    verify_required_field_exists("TSInsertRecordReq.measurements", &f_3)?;
    verify_required_field_exists("TSInsertRecordReq.values", &f_4)?;
    verify_required_field_exists("TSInsertRecordReq.timestamp", &f_5)?;
    let ret = TSInsertRecordReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prefix_path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      measurements: f_3.expect("auto-generated code should have checked for presence of required fields"),
      values: f_4.expect("auto-generated code should have checked for presence of required fields"),
      timestamp: f_5.expect("auto-generated code should have checked for presence of required fields"),
      is_aligned: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSInsertRecordReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixPath", TType::String, 2))?;
    o_prot.write_string(&self.prefix_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("measurements", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.measurements.len() as i32))?;
    for e in &self.measurements {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::String, 4))?;
    o_prot.write_bytes(&self.values)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I64, 5))?;
    o_prot.write_i64(self.timestamp)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_aligned {
      o_prot.write_field_begin(&TFieldIdentifier::new("isAligned", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSInsertStringRecordReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSInsertStringRecordReq {
  pub session_id: i64,
  pub prefix_path: String,
  pub measurements: Vec<String>,
  pub values: Vec<String>,
  pub timestamp: i64,
  pub is_aligned: Option<bool>,
}

impl TSInsertStringRecordReq {
  pub fn new<F6>(session_id: i64, prefix_path: String, measurements: Vec<String>, values: Vec<String>, timestamp: i64, is_aligned: F6) -> TSInsertStringRecordReq where F6: Into<Option<bool>> {
    TSInsertStringRecordReq {
      session_id,
      prefix_path,
      measurements,
      values,
      timestamp,
      is_aligned: is_aligned.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSInsertStringRecordReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<String>> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_20 = i_prot.read_string()?;
            val.push(list_elem_20);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_21 = i_prot.read_string()?;
            val.push(list_elem_21);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSInsertStringRecordReq.session_id", &f_1)?;
    verify_required_field_exists("TSInsertStringRecordReq.prefix_path", &f_2)?;
    verify_required_field_exists("TSInsertStringRecordReq.measurements", &f_3)?;
    verify_required_field_exists("TSInsertStringRecordReq.values", &f_4)?;
    verify_required_field_exists("TSInsertStringRecordReq.timestamp", &f_5)?;
    let ret = TSInsertStringRecordReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prefix_path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      measurements: f_3.expect("auto-generated code should have checked for presence of required fields"),
      values: f_4.expect("auto-generated code should have checked for presence of required fields"),
      timestamp: f_5.expect("auto-generated code should have checked for presence of required fields"),
      is_aligned: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSInsertStringRecordReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixPath", TType::String, 2))?;
    o_prot.write_string(&self.prefix_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("measurements", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.measurements.len() as i32))?;
    for e in &self.measurements {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.values.len() as i32))?;
    for e in &self.values {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I64, 5))?;
    o_prot.write_i64(self.timestamp)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_aligned {
      o_prot.write_field_begin(&TFieldIdentifier::new("isAligned", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSInsertTabletReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSInsertTabletReq {
  pub session_id: i64,
  pub prefix_path: String,
  pub measurements: Vec<String>,
  pub values: Vec<u8>,
  pub timestamps: Vec<u8>,
  pub types: Vec<i32>,
  pub size: i32,
  pub is_aligned: Option<bool>,
}

impl TSInsertTabletReq {
  pub fn new<F8>(session_id: i64, prefix_path: String, measurements: Vec<String>, values: Vec<u8>, timestamps: Vec<u8>, types: Vec<i32>, size: i32, is_aligned: F8) -> TSInsertTabletReq where F8: Into<Option<bool>> {
    TSInsertTabletReq {
      session_id,
      prefix_path,
      measurements,
      values,
      timestamps,
      types,
      size,
      is_aligned: is_aligned.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSInsertTabletReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<u8>> = None;
    let mut f_5: Option<Vec<u8>> = None;
    let mut f_6: Option<Vec<i32>> = None;
    let mut f_7: Option<i32> = None;
    let mut f_8: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_22 = i_prot.read_string()?;
            val.push(list_elem_22);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_23 = i_prot.read_i32()?;
            val.push(list_elem_23);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSInsertTabletReq.session_id", &f_1)?;
    verify_required_field_exists("TSInsertTabletReq.prefix_path", &f_2)?;
    verify_required_field_exists("TSInsertTabletReq.measurements", &f_3)?;
    verify_required_field_exists("TSInsertTabletReq.values", &f_4)?;
    verify_required_field_exists("TSInsertTabletReq.timestamps", &f_5)?;
    verify_required_field_exists("TSInsertTabletReq.types", &f_6)?;
    verify_required_field_exists("TSInsertTabletReq.size", &f_7)?;
    let ret = TSInsertTabletReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prefix_path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      measurements: f_3.expect("auto-generated code should have checked for presence of required fields"),
      values: f_4.expect("auto-generated code should have checked for presence of required fields"),
      timestamps: f_5.expect("auto-generated code should have checked for presence of required fields"),
      types: f_6.expect("auto-generated code should have checked for presence of required fields"),
      size: f_7.expect("auto-generated code should have checked for presence of required fields"),
      is_aligned: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSInsertTabletReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixPath", TType::String, 2))?;
    o_prot.write_string(&self.prefix_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("measurements", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.measurements.len() as i32))?;
    for e in &self.measurements {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::String, 4))?;
    o_prot.write_bytes(&self.values)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamps", TType::String, 5))?;
    o_prot.write_bytes(&self.timestamps)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("types", TType::List, 6))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.types.len() as i32))?;
    for e in &self.types {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("size", TType::I32, 7))?;
    o_prot.write_i32(self.size)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_aligned {
      o_prot.write_field_begin(&TFieldIdentifier::new("isAligned", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSInsertTabletsReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSInsertTabletsReq {
  pub session_id: i64,
  pub prefix_paths: Vec<String>,
  pub measurements_list: Vec<Vec<String>>,
  pub values_list: Vec<Vec<u8>>,
  pub timestamps_list: Vec<Vec<u8>>,
  pub types_list: Vec<Vec<i32>>,
  pub size_list: Vec<i32>,
  pub is_aligned: Option<bool>,
}

impl TSInsertTabletsReq {
  pub fn new<F8>(session_id: i64, prefix_paths: Vec<String>, measurements_list: Vec<Vec<String>>, values_list: Vec<Vec<u8>>, timestamps_list: Vec<Vec<u8>>, types_list: Vec<Vec<i32>>, size_list: Vec<i32>, is_aligned: F8) -> TSInsertTabletsReq where F8: Into<Option<bool>> {
    TSInsertTabletsReq {
      session_id,
      prefix_paths,
      measurements_list,
      values_list,
      timestamps_list,
      types_list,
      size_list,
      is_aligned: is_aligned.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSInsertTabletsReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<Vec<Vec<String>>> = None;
    let mut f_4: Option<Vec<Vec<u8>>> = None;
    let mut f_5: Option<Vec<Vec<u8>>> = None;
    let mut f_6: Option<Vec<Vec<i32>>> = None;
    let mut f_7: Option<Vec<i32>> = None;
    let mut f_8: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_24 = i_prot.read_string()?;
            val.push(list_elem_24);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_25: Vec<String> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_26 = i_prot.read_string()?;
              list_elem_25.push(list_elem_26);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_25);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_27 = i_prot.read_bytes()?;
            val.push(list_elem_27);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_28 = i_prot.read_bytes()?;
            val.push(list_elem_28);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<i32>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_29: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_30 = i_prot.read_i32()?;
              list_elem_29.push(list_elem_30);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_29);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_31 = i_prot.read_i32()?;
            val.push(list_elem_31);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSInsertTabletsReq.session_id", &f_1)?;
    verify_required_field_exists("TSInsertTabletsReq.prefix_paths", &f_2)?;
    verify_required_field_exists("TSInsertTabletsReq.measurements_list", &f_3)?;
    verify_required_field_exists("TSInsertTabletsReq.values_list", &f_4)?;
    verify_required_field_exists("TSInsertTabletsReq.timestamps_list", &f_5)?;
    verify_required_field_exists("TSInsertTabletsReq.types_list", &f_6)?;
    verify_required_field_exists("TSInsertTabletsReq.size_list", &f_7)?;
    let ret = TSInsertTabletsReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prefix_paths: f_2.expect("auto-generated code should have checked for presence of required fields"),
      measurements_list: f_3.expect("auto-generated code should have checked for presence of required fields"),
      values_list: f_4.expect("auto-generated code should have checked for presence of required fields"),
      timestamps_list: f_5.expect("auto-generated code should have checked for presence of required fields"),
      types_list: f_6.expect("auto-generated code should have checked for presence of required fields"),
      size_list: f_7.expect("auto-generated code should have checked for presence of required fields"),
      is_aligned: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSInsertTabletsReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixPaths", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.prefix_paths.len() as i32))?;
    for e in &self.prefix_paths {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("measurementsList", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.measurements_list.len() as i32))?;
    for e in &self.measurements_list {
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, e.len() as i32))?;
      for e in e {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("valuesList", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.values_list.len() as i32))?;
    for e in &self.values_list {
      o_prot.write_bytes(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestampsList", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.timestamps_list.len() as i32))?;
    for e in &self.timestamps_list {
      o_prot.write_bytes(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("typesList", TType::List, 6))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.types_list.len() as i32))?;
    for e in &self.types_list {
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, e.len() as i32))?;
      for e in e {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sizeList", TType::List, 7))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.size_list.len() as i32))?;
    for e in &self.size_list {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_aligned {
      o_prot.write_field_begin(&TFieldIdentifier::new("isAligned", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSInsertRecordsReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSInsertRecordsReq {
  pub session_id: i64,
  pub prefix_paths: Vec<String>,
  pub measurements_list: Vec<Vec<String>>,
  pub values_list: Vec<Vec<u8>>,
  pub timestamps: Vec<i64>,
  pub is_aligned: Option<bool>,
}

impl TSInsertRecordsReq {
  pub fn new<F6>(session_id: i64, prefix_paths: Vec<String>, measurements_list: Vec<Vec<String>>, values_list: Vec<Vec<u8>>, timestamps: Vec<i64>, is_aligned: F6) -> TSInsertRecordsReq where F6: Into<Option<bool>> {
    TSInsertRecordsReq {
      session_id,
      prefix_paths,
      measurements_list,
      values_list,
      timestamps,
      is_aligned: is_aligned.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSInsertRecordsReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<Vec<Vec<String>>> = None;
    let mut f_4: Option<Vec<Vec<u8>>> = None;
    let mut f_5: Option<Vec<i64>> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_32 = i_prot.read_string()?;
            val.push(list_elem_32);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_33: Vec<String> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_34 = i_prot.read_string()?;
              list_elem_33.push(list_elem_34);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_33);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_35 = i_prot.read_bytes()?;
            val.push(list_elem_35);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_36 = i_prot.read_i64()?;
            val.push(list_elem_36);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSInsertRecordsReq.session_id", &f_1)?;
    verify_required_field_exists("TSInsertRecordsReq.prefix_paths", &f_2)?;
    verify_required_field_exists("TSInsertRecordsReq.measurements_list", &f_3)?;
    verify_required_field_exists("TSInsertRecordsReq.values_list", &f_4)?;
    verify_required_field_exists("TSInsertRecordsReq.timestamps", &f_5)?;
    let ret = TSInsertRecordsReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prefix_paths: f_2.expect("auto-generated code should have checked for presence of required fields"),
      measurements_list: f_3.expect("auto-generated code should have checked for presence of required fields"),
      values_list: f_4.expect("auto-generated code should have checked for presence of required fields"),
      timestamps: f_5.expect("auto-generated code should have checked for presence of required fields"),
      is_aligned: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSInsertRecordsReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixPaths", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.prefix_paths.len() as i32))?;
    for e in &self.prefix_paths {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("measurementsList", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.measurements_list.len() as i32))?;
    for e in &self.measurements_list {
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, e.len() as i32))?;
      for e in e {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("valuesList", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.values_list.len() as i32))?;
    for e in &self.values_list {
      o_prot.write_bytes(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamps", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.timestamps.len() as i32))?;
    for e in &self.timestamps {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_aligned {
      o_prot.write_field_begin(&TFieldIdentifier::new("isAligned", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSInsertRecordsOfOneDeviceReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSInsertRecordsOfOneDeviceReq {
  pub session_id: i64,
  pub prefix_path: String,
  pub measurements_list: Vec<Vec<String>>,
  pub values_list: Vec<Vec<u8>>,
  pub timestamps: Vec<i64>,
  pub is_aligned: Option<bool>,
}

impl TSInsertRecordsOfOneDeviceReq {
  pub fn new<F6>(session_id: i64, prefix_path: String, measurements_list: Vec<Vec<String>>, values_list: Vec<Vec<u8>>, timestamps: Vec<i64>, is_aligned: F6) -> TSInsertRecordsOfOneDeviceReq where F6: Into<Option<bool>> {
    TSInsertRecordsOfOneDeviceReq {
      session_id,
      prefix_path,
      measurements_list,
      values_list,
      timestamps,
      is_aligned: is_aligned.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSInsertRecordsOfOneDeviceReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<Vec<String>>> = None;
    let mut f_4: Option<Vec<Vec<u8>>> = None;
    let mut f_5: Option<Vec<i64>> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_37: Vec<String> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_38 = i_prot.read_string()?;
              list_elem_37.push(list_elem_38);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_37);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_39 = i_prot.read_bytes()?;
            val.push(list_elem_39);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_40 = i_prot.read_i64()?;
            val.push(list_elem_40);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSInsertRecordsOfOneDeviceReq.session_id", &f_1)?;
    verify_required_field_exists("TSInsertRecordsOfOneDeviceReq.prefix_path", &f_2)?;
    verify_required_field_exists("TSInsertRecordsOfOneDeviceReq.measurements_list", &f_3)?;
    verify_required_field_exists("TSInsertRecordsOfOneDeviceReq.values_list", &f_4)?;
    verify_required_field_exists("TSInsertRecordsOfOneDeviceReq.timestamps", &f_5)?;
    let ret = TSInsertRecordsOfOneDeviceReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prefix_path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      measurements_list: f_3.expect("auto-generated code should have checked for presence of required fields"),
      values_list: f_4.expect("auto-generated code should have checked for presence of required fields"),
      timestamps: f_5.expect("auto-generated code should have checked for presence of required fields"),
      is_aligned: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSInsertRecordsOfOneDeviceReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixPath", TType::String, 2))?;
    o_prot.write_string(&self.prefix_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("measurementsList", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.measurements_list.len() as i32))?;
    for e in &self.measurements_list {
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, e.len() as i32))?;
      for e in e {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("valuesList", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.values_list.len() as i32))?;
    for e in &self.values_list {
      o_prot.write_bytes(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamps", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.timestamps.len() as i32))?;
    for e in &self.timestamps {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_aligned {
      o_prot.write_field_begin(&TFieldIdentifier::new("isAligned", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSInsertStringRecordsReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSInsertStringRecordsReq {
  pub session_id: i64,
  pub prefix_paths: Vec<String>,
  pub measurements_list: Vec<Vec<String>>,
  pub values_list: Vec<Vec<String>>,
  pub timestamps: Vec<i64>,
  pub is_aligned: Option<bool>,
}

impl TSInsertStringRecordsReq {
  pub fn new<F6>(session_id: i64, prefix_paths: Vec<String>, measurements_list: Vec<Vec<String>>, values_list: Vec<Vec<String>>, timestamps: Vec<i64>, is_aligned: F6) -> TSInsertStringRecordsReq where F6: Into<Option<bool>> {
    TSInsertStringRecordsReq {
      session_id,
      prefix_paths,
      measurements_list,
      values_list,
      timestamps,
      is_aligned: is_aligned.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSInsertStringRecordsReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<Vec<Vec<String>>> = None;
    let mut f_4: Option<Vec<Vec<String>>> = None;
    let mut f_5: Option<Vec<i64>> = None;
    let mut f_6: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_41 = i_prot.read_string()?;
            val.push(list_elem_41);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_42: Vec<String> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_43 = i_prot.read_string()?;
              list_elem_42.push(list_elem_43);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_42);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_44: Vec<String> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_45 = i_prot.read_string()?;
              list_elem_44.push(list_elem_45);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_44);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_46 = i_prot.read_i64()?;
            val.push(list_elem_46);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSInsertStringRecordsReq.session_id", &f_1)?;
    verify_required_field_exists("TSInsertStringRecordsReq.prefix_paths", &f_2)?;
    verify_required_field_exists("TSInsertStringRecordsReq.measurements_list", &f_3)?;
    verify_required_field_exists("TSInsertStringRecordsReq.values_list", &f_4)?;
    verify_required_field_exists("TSInsertStringRecordsReq.timestamps", &f_5)?;
    let ret = TSInsertStringRecordsReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prefix_paths: f_2.expect("auto-generated code should have checked for presence of required fields"),
      measurements_list: f_3.expect("auto-generated code should have checked for presence of required fields"),
      values_list: f_4.expect("auto-generated code should have checked for presence of required fields"),
      timestamps: f_5.expect("auto-generated code should have checked for presence of required fields"),
      is_aligned: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSInsertStringRecordsReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixPaths", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.prefix_paths.len() as i32))?;
    for e in &self.prefix_paths {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("measurementsList", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.measurements_list.len() as i32))?;
    for e in &self.measurements_list {
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, e.len() as i32))?;
      for e in e {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("valuesList", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.values_list.len() as i32))?;
    for e in &self.values_list {
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, e.len() as i32))?;
      for e in e {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamps", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I64, self.timestamps.len() as i32))?;
    for e in &self.timestamps {
      o_prot.write_i64(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.is_aligned {
      o_prot.write_field_begin(&TFieldIdentifier::new("isAligned", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSDeleteDataReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSDeleteDataReq {
  pub session_id: i64,
  pub paths: Vec<String>,
  pub start_time: i64,
  pub end_time: i64,
}

impl TSDeleteDataReq {
  pub fn new(session_id: i64, paths: Vec<String>, start_time: i64, end_time: i64) -> TSDeleteDataReq {
    TSDeleteDataReq {
      session_id,
      paths,
      start_time,
      end_time,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSDeleteDataReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_47 = i_prot.read_string()?;
            val.push(list_elem_47);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSDeleteDataReq.session_id", &f_1)?;
    verify_required_field_exists("TSDeleteDataReq.paths", &f_2)?;
    verify_required_field_exists("TSDeleteDataReq.start_time", &f_3)?;
    verify_required_field_exists("TSDeleteDataReq.end_time", &f_4)?;
    let ret = TSDeleteDataReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      paths: f_2.expect("auto-generated code should have checked for presence of required fields"),
      start_time: f_3.expect("auto-generated code should have checked for presence of required fields"),
      end_time: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSDeleteDataReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("paths", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.paths.len() as i32))?;
    for e in &self.paths {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("startTime", TType::I64, 3))?;
    o_prot.write_i64(self.start_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("endTime", TType::I64, 4))?;
    o_prot.write_i64(self.end_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSCreateTimeseriesReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSCreateTimeseriesReq {
  pub session_id: i64,
  pub path: String,
  pub data_type: i32,
  pub encoding: i32,
  pub compressor: i32,
  pub props: Option<BTreeMap<String, String>>,
  pub tags: Option<BTreeMap<String, String>>,
  pub attributes: Option<BTreeMap<String, String>>,
  pub measurement_alias: Option<String>,
}

impl TSCreateTimeseriesReq {
  pub fn new<F6, F7, F8, F9>(session_id: i64, path: String, data_type: i32, encoding: i32, compressor: i32, props: F6, tags: F7, attributes: F8, measurement_alias: F9) -> TSCreateTimeseriesReq where F6: Into<Option<BTreeMap<String, String>>>, F7: Into<Option<BTreeMap<String, String>>>, F8: Into<Option<BTreeMap<String, String>>>, F9: Into<Option<String>> {
    TSCreateTimeseriesReq {
      session_id,
      path,
      data_type,
      encoding,
      compressor,
      props: props.into(),
      tags: tags.into(),
      attributes: attributes.into(),
      measurement_alias: measurement_alias.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSCreateTimeseriesReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<BTreeMap<String, String>> = None;
    let mut f_7: Option<BTreeMap<String, String>> = None;
    let mut f_8: Option<BTreeMap<String, String>> = None;
    let mut f_9: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_48 = i_prot.read_string()?;
            let map_val_49 = i_prot.read_string()?;
            val.insert(map_key_48, map_val_49);
          }
          i_prot.read_map_end()?;
          f_6 = Some(val);
        },
        7 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_50 = i_prot.read_string()?;
            let map_val_51 = i_prot.read_string()?;
            val.insert(map_key_50, map_val_51);
          }
          i_prot.read_map_end()?;
          f_7 = Some(val);
        },
        8 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_52 = i_prot.read_string()?;
            let map_val_53 = i_prot.read_string()?;
            val.insert(map_key_52, map_val_53);
          }
          i_prot.read_map_end()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSCreateTimeseriesReq.session_id", &f_1)?;
    verify_required_field_exists("TSCreateTimeseriesReq.path", &f_2)?;
    verify_required_field_exists("TSCreateTimeseriesReq.data_type", &f_3)?;
    verify_required_field_exists("TSCreateTimeseriesReq.encoding", &f_4)?;
    verify_required_field_exists("TSCreateTimeseriesReq.compressor", &f_5)?;
    let ret = TSCreateTimeseriesReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      data_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
      encoding: f_4.expect("auto-generated code should have checked for presence of required fields"),
      compressor: f_5.expect("auto-generated code should have checked for presence of required fields"),
      props: f_6,
      tags: f_7,
      attributes: f_8,
      measurement_alias: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSCreateTimeseriesReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("path", TType::String, 2))?;
    o_prot.write_string(&self.path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dataType", TType::I32, 3))?;
    o_prot.write_i32(self.data_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encoding", TType::I32, 4))?;
    o_prot.write_i32(self.encoding)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("compressor", TType::I32, 5))?;
    o_prot.write_i32(self.compressor)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.props {
      o_prot.write_field_begin(&TFieldIdentifier::new("props", TType::Map, 6))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tags {
      o_prot.write_field_begin(&TFieldIdentifier::new("tags", TType::Map, 7))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("attributes", TType::Map, 8))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.measurement_alias {
      o_prot.write_field_begin(&TFieldIdentifier::new("measurementAlias", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSCreateAlignedTimeseriesReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSCreateAlignedTimeseriesReq {
  pub session_id: i64,
  pub prefix_path: String,
  pub measurements: Vec<String>,
  pub data_types: Vec<i32>,
  pub encodings: Vec<i32>,
  pub compressor: i32,
  pub measurement_alias: Option<Vec<String>>,
}

impl TSCreateAlignedTimeseriesReq {
  pub fn new<F7>(session_id: i64, prefix_path: String, measurements: Vec<String>, data_types: Vec<i32>, encodings: Vec<i32>, compressor: i32, measurement_alias: F7) -> TSCreateAlignedTimeseriesReq where F7: Into<Option<Vec<String>>> {
    TSCreateAlignedTimeseriesReq {
      session_id,
      prefix_path,
      measurements,
      data_types,
      encodings,
      compressor,
      measurement_alias: measurement_alias.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSCreateAlignedTimeseriesReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<i32>> = None;
    let mut f_5: Option<Vec<i32>> = None;
    let mut f_6: Option<i32> = None;
    let mut f_7: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_54 = i_prot.read_string()?;
            val.push(list_elem_54);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_55 = i_prot.read_i32()?;
            val.push(list_elem_55);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_56 = i_prot.read_i32()?;
            val.push(list_elem_56);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_57 = i_prot.read_string()?;
            val.push(list_elem_57);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSCreateAlignedTimeseriesReq.session_id", &f_1)?;
    verify_required_field_exists("TSCreateAlignedTimeseriesReq.prefix_path", &f_2)?;
    verify_required_field_exists("TSCreateAlignedTimeseriesReq.measurements", &f_3)?;
    verify_required_field_exists("TSCreateAlignedTimeseriesReq.data_types", &f_4)?;
    verify_required_field_exists("TSCreateAlignedTimeseriesReq.encodings", &f_5)?;
    verify_required_field_exists("TSCreateAlignedTimeseriesReq.compressor", &f_6)?;
    let ret = TSCreateAlignedTimeseriesReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prefix_path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      measurements: f_3.expect("auto-generated code should have checked for presence of required fields"),
      data_types: f_4.expect("auto-generated code should have checked for presence of required fields"),
      encodings: f_5.expect("auto-generated code should have checked for presence of required fields"),
      compressor: f_6.expect("auto-generated code should have checked for presence of required fields"),
      measurement_alias: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSCreateAlignedTimeseriesReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixPath", TType::String, 2))?;
    o_prot.write_string(&self.prefix_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("measurements", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.measurements.len() as i32))?;
    for e in &self.measurements {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dataTypes", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.data_types.len() as i32))?;
    for e in &self.data_types {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encodings", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.encodings.len() as i32))?;
    for e in &self.encodings {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("compressor", TType::I32, 6))?;
    o_prot.write_i32(self.compressor)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.measurement_alias {
      o_prot.write_field_begin(&TFieldIdentifier::new("measurementAlias", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSRawDataQueryReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSRawDataQueryReq {
  pub session_id: i64,
  pub paths: Vec<String>,
  pub fetch_size: Option<i32>,
  pub start_time: i64,
  pub end_time: i64,
  pub statement_id: i64,
  pub enable_redirect_query: Option<bool>,
  pub jdbc_query: Option<bool>,
}

impl TSRawDataQueryReq {
  pub fn new<F3, F7, F8>(session_id: i64, paths: Vec<String>, fetch_size: F3, start_time: i64, end_time: i64, statement_id: i64, enable_redirect_query: F7, jdbc_query: F8) -> TSRawDataQueryReq where F3: Into<Option<i32>>, F7: Into<Option<bool>>, F8: Into<Option<bool>> {
    TSRawDataQueryReq {
      session_id,
      paths,
      fetch_size: fetch_size.into(),
      start_time,
      end_time,
      statement_id,
      enable_redirect_query: enable_redirect_query.into(),
      jdbc_query: jdbc_query.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSRawDataQueryReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<i64> = None;
    let mut f_7: Option<bool> = None;
    let mut f_8: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_58 = i_prot.read_string()?;
            val.push(list_elem_58);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSRawDataQueryReq.session_id", &f_1)?;
    verify_required_field_exists("TSRawDataQueryReq.paths", &f_2)?;
    verify_required_field_exists("TSRawDataQueryReq.start_time", &f_4)?;
    verify_required_field_exists("TSRawDataQueryReq.end_time", &f_5)?;
    verify_required_field_exists("TSRawDataQueryReq.statement_id", &f_6)?;
    let ret = TSRawDataQueryReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      paths: f_2.expect("auto-generated code should have checked for presence of required fields"),
      fetch_size: f_3,
      start_time: f_4.expect("auto-generated code should have checked for presence of required fields"),
      end_time: f_5.expect("auto-generated code should have checked for presence of required fields"),
      statement_id: f_6.expect("auto-generated code should have checked for presence of required fields"),
      enable_redirect_query: f_7,
      jdbc_query: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSRawDataQueryReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("paths", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.paths.len() as i32))?;
    for e in &self.paths {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.fetch_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("fetchSize", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("startTime", TType::I64, 4))?;
    o_prot.write_i64(self.start_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("endTime", TType::I64, 5))?;
    o_prot.write_i64(self.end_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("statementId", TType::I64, 6))?;
    o_prot.write_i64(self.statement_id)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.enable_redirect_query {
      o_prot.write_field_begin(&TFieldIdentifier::new("enableRedirectQuery", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.jdbc_query {
      o_prot.write_field_begin(&TFieldIdentifier::new("jdbcQuery", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSLastDataQueryReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSLastDataQueryReq {
  pub session_id: i64,
  pub paths: Vec<String>,
  pub fetch_size: Option<i32>,
  pub time: i64,
  pub statement_id: i64,
  pub enable_redirect_query: Option<bool>,
  pub jdbc_query: Option<bool>,
}

impl TSLastDataQueryReq {
  pub fn new<F3, F6, F7>(session_id: i64, paths: Vec<String>, fetch_size: F3, time: i64, statement_id: i64, enable_redirect_query: F6, jdbc_query: F7) -> TSLastDataQueryReq where F3: Into<Option<i32>>, F6: Into<Option<bool>>, F7: Into<Option<bool>> {
    TSLastDataQueryReq {
      session_id,
      paths,
      fetch_size: fetch_size.into(),
      time,
      statement_id,
      enable_redirect_query: enable_redirect_query.into(),
      jdbc_query: jdbc_query.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSLastDataQueryReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_59 = i_prot.read_string()?;
            val.push(list_elem_59);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSLastDataQueryReq.session_id", &f_1)?;
    verify_required_field_exists("TSLastDataQueryReq.paths", &f_2)?;
    verify_required_field_exists("TSLastDataQueryReq.time", &f_4)?;
    verify_required_field_exists("TSLastDataQueryReq.statement_id", &f_5)?;
    let ret = TSLastDataQueryReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      paths: f_2.expect("auto-generated code should have checked for presence of required fields"),
      fetch_size: f_3,
      time: f_4.expect("auto-generated code should have checked for presence of required fields"),
      statement_id: f_5.expect("auto-generated code should have checked for presence of required fields"),
      enable_redirect_query: f_6,
      jdbc_query: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSLastDataQueryReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("paths", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.paths.len() as i32))?;
    for e in &self.paths {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.fetch_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("fetchSize", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("time", TType::I64, 4))?;
    o_prot.write_i64(self.time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("statementId", TType::I64, 5))?;
    o_prot.write_i64(self.statement_id)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.enable_redirect_query {
      o_prot.write_field_begin(&TFieldIdentifier::new("enableRedirectQuery", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.jdbc_query {
      o_prot.write_field_begin(&TFieldIdentifier::new("jdbcQuery", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSCreateMultiTimeseriesReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSCreateMultiTimeseriesReq {
  pub session_id: i64,
  pub paths: Vec<String>,
  pub data_types: Vec<i32>,
  pub encodings: Vec<i32>,
  pub compressors: Vec<i32>,
  pub props_list: Option<Vec<BTreeMap<String, String>>>,
  pub tags_list: Option<Vec<BTreeMap<String, String>>>,
  pub attributes_list: Option<Vec<BTreeMap<String, String>>>,
  pub measurement_alias_list: Option<Vec<String>>,
}

impl TSCreateMultiTimeseriesReq {
  pub fn new<F6, F7, F8, F9>(session_id: i64, paths: Vec<String>, data_types: Vec<i32>, encodings: Vec<i32>, compressors: Vec<i32>, props_list: F6, tags_list: F7, attributes_list: F8, measurement_alias_list: F9) -> TSCreateMultiTimeseriesReq where F6: Into<Option<Vec<BTreeMap<String, String>>>>, F7: Into<Option<Vec<BTreeMap<String, String>>>>, F8: Into<Option<Vec<BTreeMap<String, String>>>>, F9: Into<Option<Vec<String>>> {
    TSCreateMultiTimeseriesReq {
      session_id,
      paths,
      data_types,
      encodings,
      compressors,
      props_list: props_list.into(),
      tags_list: tags_list.into(),
      attributes_list: attributes_list.into(),
      measurement_alias_list: measurement_alias_list.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSCreateMultiTimeseriesReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<Vec<i32>> = None;
    let mut f_4: Option<Vec<i32>> = None;
    let mut f_5: Option<Vec<i32>> = None;
    let mut f_6: Option<Vec<BTreeMap<String, String>>> = None;
    let mut f_7: Option<Vec<BTreeMap<String, String>>> = None;
    let mut f_8: Option<Vec<BTreeMap<String, String>>> = None;
    let mut f_9: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_60 = i_prot.read_string()?;
            val.push(list_elem_60);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_61 = i_prot.read_i32()?;
            val.push(list_elem_61);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_62 = i_prot.read_i32()?;
            val.push(list_elem_62);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_63 = i_prot.read_i32()?;
            val.push(list_elem_63);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<BTreeMap<String, String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let map_ident = i_prot.read_map_begin()?;
            let mut list_elem_64: BTreeMap<String, String> = BTreeMap::new();
            for _ in 0..map_ident.size {
              let map_key_65 = i_prot.read_string()?;
              let map_val_66 = i_prot.read_string()?;
              list_elem_64.insert(map_key_65, map_val_66);
            }
            i_prot.read_map_end()?;
            val.push(list_elem_64);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<BTreeMap<String, String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let map_ident = i_prot.read_map_begin()?;
            let mut list_elem_67: BTreeMap<String, String> = BTreeMap::new();
            for _ in 0..map_ident.size {
              let map_key_68 = i_prot.read_string()?;
              let map_val_69 = i_prot.read_string()?;
              list_elem_67.insert(map_key_68, map_val_69);
            }
            i_prot.read_map_end()?;
            val.push(list_elem_67);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<BTreeMap<String, String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let map_ident = i_prot.read_map_begin()?;
            let mut list_elem_70: BTreeMap<String, String> = BTreeMap::new();
            for _ in 0..map_ident.size {
              let map_key_71 = i_prot.read_string()?;
              let map_val_72 = i_prot.read_string()?;
              list_elem_70.insert(map_key_71, map_val_72);
            }
            i_prot.read_map_end()?;
            val.push(list_elem_70);
          }
          i_prot.read_list_end()?;
          f_8 = Some(val);
        },
        9 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_73 = i_prot.read_string()?;
            val.push(list_elem_73);
          }
          i_prot.read_list_end()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSCreateMultiTimeseriesReq.session_id", &f_1)?;
    verify_required_field_exists("TSCreateMultiTimeseriesReq.paths", &f_2)?;
    verify_required_field_exists("TSCreateMultiTimeseriesReq.data_types", &f_3)?;
    verify_required_field_exists("TSCreateMultiTimeseriesReq.encodings", &f_4)?;
    verify_required_field_exists("TSCreateMultiTimeseriesReq.compressors", &f_5)?;
    let ret = TSCreateMultiTimeseriesReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      paths: f_2.expect("auto-generated code should have checked for presence of required fields"),
      data_types: f_3.expect("auto-generated code should have checked for presence of required fields"),
      encodings: f_4.expect("auto-generated code should have checked for presence of required fields"),
      compressors: f_5.expect("auto-generated code should have checked for presence of required fields"),
      props_list: f_6,
      tags_list: f_7,
      attributes_list: f_8,
      measurement_alias_list: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSCreateMultiTimeseriesReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("paths", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.paths.len() as i32))?;
    for e in &self.paths {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dataTypes", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.data_types.len() as i32))?;
    for e in &self.data_types {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encodings", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.encodings.len() as i32))?;
    for e in &self.encodings {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("compressors", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.compressors.len() as i32))?;
    for e in &self.compressors {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.props_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("propsList", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Map, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, e.len() as i32))?;
        for (k, v) in e {
          o_prot.write_string(k)?;
          o_prot.write_string(v)?;
        }
        o_prot.write_map_end()?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tags_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("tagsList", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Map, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, e.len() as i32))?;
        for (k, v) in e {
          o_prot.write_string(k)?;
          o_prot.write_string(v)?;
        }
        o_prot.write_map_end()?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.attributes_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("attributesList", TType::List, 8))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Map, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, e.len() as i32))?;
        for (k, v) in e {
          o_prot.write_string(k)?;
          o_prot.write_string(v)?;
        }
        o_prot.write_map_end()?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.measurement_alias_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("measurementAliasList", TType::List, 9))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServerProperties
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ServerProperties {
  pub version: String,
  pub supported_time_aggregation_operations: Vec<String>,
  pub timestamp_precision: String,
  pub max_concurrent_client_num: Option<i32>,
  pub watermark_secret_key: Option<String>,
  pub watermark_bit_string: Option<String>,
  pub watermark_param_mark_rate: Option<i32>,
  pub watermark_param_max_right_bit: Option<i32>,
  pub thrift_max_frame_size: Option<i32>,
  pub is_read_only: Option<bool>,
}

impl ServerProperties {
  pub fn new<F4, F5, F6, F7, F8, F9, F10>(version: String, supported_time_aggregation_operations: Vec<String>, timestamp_precision: String, max_concurrent_client_num: F4, watermark_secret_key: F5, watermark_bit_string: F6, watermark_param_mark_rate: F7, watermark_param_max_right_bit: F8, thrift_max_frame_size: F9, is_read_only: F10) -> ServerProperties where F4: Into<Option<i32>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<i32>>, F8: Into<Option<i32>>, F9: Into<Option<i32>>, F10: Into<Option<bool>> {
    ServerProperties {
      version,
      supported_time_aggregation_operations,
      timestamp_precision,
      max_concurrent_client_num: max_concurrent_client_num.into(),
      watermark_secret_key: watermark_secret_key.into(),
      watermark_bit_string: watermark_bit_string.into(),
      watermark_param_mark_rate: watermark_param_mark_rate.into(),
      watermark_param_max_right_bit: watermark_param_max_right_bit.into(),
      thrift_max_frame_size: thrift_max_frame_size.into(),
      is_read_only: is_read_only.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServerProperties> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = Some(0);
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<i32> = None;
    let mut f_8: Option<i32> = None;
    let mut f_9: Option<i32> = None;
    let mut f_10: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_74 = i_prot.read_string()?;
            val.push(list_elem_74);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i32()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServerProperties.version", &f_1)?;
    verify_required_field_exists("ServerProperties.supported_time_aggregation_operations", &f_2)?;
    verify_required_field_exists("ServerProperties.timestamp_precision", &f_3)?;
    let ret = ServerProperties {
      version: f_1.expect("auto-generated code should have checked for presence of required fields"),
      supported_time_aggregation_operations: f_2.expect("auto-generated code should have checked for presence of required fields"),
      timestamp_precision: f_3.expect("auto-generated code should have checked for presence of required fields"),
      max_concurrent_client_num: f_4,
      watermark_secret_key: f_5,
      watermark_bit_string: f_6,
      watermark_param_mark_rate: f_7,
      watermark_param_max_right_bit: f_8,
      thrift_max_frame_size: f_9,
      is_read_only: f_10,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServerProperties");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::String, 1))?;
    o_prot.write_string(&self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("supportedTimeAggregationOperations", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.supported_time_aggregation_operations.len() as i32))?;
    for e in &self.supported_time_aggregation_operations {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestampPrecision", TType::String, 3))?;
    o_prot.write_string(&self.timestamp_precision)?;
    o_prot.write_field_end()?;
    if let Some(fld_var) = self.max_concurrent_client_num {
      o_prot.write_field_begin(&TFieldIdentifier::new("maxConcurrentClientNum", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.watermark_secret_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("watermarkSecretKey", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.watermark_bit_string {
      o_prot.write_field_begin(&TFieldIdentifier::new("watermarkBitString", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.watermark_param_mark_rate {
      o_prot.write_field_begin(&TFieldIdentifier::new("watermarkParamMarkRate", TType::I32, 7))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.watermark_param_max_right_bit {
      o_prot.write_field_begin(&TFieldIdentifier::new("watermarkParamMaxRightBit", TType::I32, 8))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.thrift_max_frame_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("thriftMaxFrameSize", TType::I32, 9))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_read_only {
      o_prot.write_field_begin(&TFieldIdentifier::new("isReadOnly", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSSetSchemaTemplateReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSSetSchemaTemplateReq {
  pub session_id: i64,
  pub template_name: String,
  pub prefix_path: String,
}

impl TSSetSchemaTemplateReq {
  pub fn new(session_id: i64, template_name: String, prefix_path: String) -> TSSetSchemaTemplateReq {
    TSSetSchemaTemplateReq {
      session_id,
      template_name,
      prefix_path,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSSetSchemaTemplateReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSSetSchemaTemplateReq.session_id", &f_1)?;
    verify_required_field_exists("TSSetSchemaTemplateReq.template_name", &f_2)?;
    verify_required_field_exists("TSSetSchemaTemplateReq.prefix_path", &f_3)?;
    let ret = TSSetSchemaTemplateReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      template_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      prefix_path: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSSetSchemaTemplateReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("templateName", TType::String, 2))?;
    o_prot.write_string(&self.template_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixPath", TType::String, 3))?;
    o_prot.write_string(&self.prefix_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSCreateSchemaTemplateReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSCreateSchemaTemplateReq {
  pub session_id: i64,
  pub name: String,
  pub schema_names: Vec<String>,
  pub measurements: Vec<Vec<String>>,
  pub data_types: Vec<Vec<i32>>,
  pub encodings: Vec<Vec<i32>>,
  pub compressors: Vec<i32>,
}

impl TSCreateSchemaTemplateReq {
  pub fn new(session_id: i64, name: String, schema_names: Vec<String>, measurements: Vec<Vec<String>>, data_types: Vec<Vec<i32>>, encodings: Vec<Vec<i32>>, compressors: Vec<i32>) -> TSCreateSchemaTemplateReq {
    TSCreateSchemaTemplateReq {
      session_id,
      name,
      schema_names,
      measurements,
      data_types,
      encodings,
      compressors,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSCreateSchemaTemplateReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<Vec<String>>> = None;
    let mut f_5: Option<Vec<Vec<i32>>> = None;
    let mut f_6: Option<Vec<Vec<i32>>> = None;
    let mut f_7: Option<Vec<i32>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_75 = i_prot.read_string()?;
            val.push(list_elem_75);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<String>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_76: Vec<String> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_77 = i_prot.read_string()?;
              list_elem_76.push(list_elem_77);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_76);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<i32>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_78: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_79 = i_prot.read_i32()?;
              list_elem_78.push(list_elem_79);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_78);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<i32>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_ident = i_prot.read_list_begin()?;
            let mut list_elem_80: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_81 = i_prot.read_i32()?;
              list_elem_80.push(list_elem_81);
            }
            i_prot.read_list_end()?;
            val.push(list_elem_80);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_82 = i_prot.read_i32()?;
            val.push(list_elem_82);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSCreateSchemaTemplateReq.session_id", &f_1)?;
    verify_required_field_exists("TSCreateSchemaTemplateReq.name", &f_2)?;
    verify_required_field_exists("TSCreateSchemaTemplateReq.schema_names", &f_3)?;
    verify_required_field_exists("TSCreateSchemaTemplateReq.measurements", &f_4)?;
    verify_required_field_exists("TSCreateSchemaTemplateReq.data_types", &f_5)?;
    verify_required_field_exists("TSCreateSchemaTemplateReq.encodings", &f_6)?;
    verify_required_field_exists("TSCreateSchemaTemplateReq.compressors", &f_7)?;
    let ret = TSCreateSchemaTemplateReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      schema_names: f_3.expect("auto-generated code should have checked for presence of required fields"),
      measurements: f_4.expect("auto-generated code should have checked for presence of required fields"),
      data_types: f_5.expect("auto-generated code should have checked for presence of required fields"),
      encodings: f_6.expect("auto-generated code should have checked for presence of required fields"),
      compressors: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSCreateSchemaTemplateReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("schemaNames", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.schema_names.len() as i32))?;
    for e in &self.schema_names {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("measurements", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.measurements.len() as i32))?;
    for e in &self.measurements {
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, e.len() as i32))?;
      for e in e {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dataTypes", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.data_types.len() as i32))?;
    for e in &self.data_types {
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, e.len() as i32))?;
      for e in e {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encodings", TType::List, 6))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::List, self.encodings.len() as i32))?;
    for e in &self.encodings {
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, e.len() as i32))?;
      for e in e {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("compressors", TType::List, 7))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.compressors.len() as i32))?;
    for e in &self.compressors {
      o_prot.write_i32(*e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSUnsetSchemaTemplateReq
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TSUnsetSchemaTemplateReq {
  pub session_id: i64,
  pub prefix_path: String,
  pub template_name: String,
}

impl TSUnsetSchemaTemplateReq {
  pub fn new(session_id: i64, prefix_path: String, template_name: String) -> TSUnsetSchemaTemplateReq {
    TSUnsetSchemaTemplateReq {
      session_id,
      prefix_path,
      template_name,
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSUnsetSchemaTemplateReq> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSUnsetSchemaTemplateReq.session_id", &f_1)?;
    verify_required_field_exists("TSUnsetSchemaTemplateReq.prefix_path", &f_2)?;
    verify_required_field_exists("TSUnsetSchemaTemplateReq.template_name", &f_3)?;
    let ret = TSUnsetSchemaTemplateReq {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      prefix_path: f_2.expect("auto-generated code should have checked for presence of required fields"),
      template_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSUnsetSchemaTemplateReq");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("prefixPath", TType::String, 2))?;
    o_prot.write_string(&self.prefix_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("templateName", TType::String, 3))?;
    o_prot.write_string(&self.template_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIService service client
//

pub trait TTSIServiceSyncClient {
  fn open_session(&mut self, req: TSOpenSessionReq) -> thrift::Result<TSOpenSessionResp>;
  fn close_session(&mut self, req: TSCloseSessionReq) -> thrift::Result<TSStatus>;
  fn execute_statement(&mut self, req: TSExecuteStatementReq) -> thrift::Result<TSExecuteStatementResp>;
  fn execute_batch_statement(&mut self, req: TSExecuteBatchStatementReq) -> thrift::Result<TSStatus>;
  fn execute_query_statement(&mut self, req: TSExecuteStatementReq) -> thrift::Result<TSExecuteStatementResp>;
  fn execute_update_statement(&mut self, req: TSExecuteStatementReq) -> thrift::Result<TSExecuteStatementResp>;
  fn fetch_results(&mut self, req: TSFetchResultsReq) -> thrift::Result<TSFetchResultsResp>;
  fn fetch_metadata(&mut self, req: TSFetchMetadataReq) -> thrift::Result<TSFetchMetadataResp>;
  fn cancel_operation(&mut self, req: TSCancelOperationReq) -> thrift::Result<TSStatus>;
  fn close_operation(&mut self, req: TSCloseOperationReq) -> thrift::Result<TSStatus>;
  fn get_time_zone(&mut self, session_id: i64) -> thrift::Result<TSGetTimeZoneResp>;
  fn set_time_zone(&mut self, req: TSSetTimeZoneReq) -> thrift::Result<TSStatus>;
  fn get_properties(&mut self) -> thrift::Result<ServerProperties>;
  fn set_storage_group(&mut self, session_id: i64, storage_group: String) -> thrift::Result<TSStatus>;
  fn create_timeseries(&mut self, req: TSCreateTimeseriesReq) -> thrift::Result<TSStatus>;
  fn create_aligned_timeseries(&mut self, req: TSCreateAlignedTimeseriesReq) -> thrift::Result<TSStatus>;
  fn create_multi_timeseries(&mut self, req: TSCreateMultiTimeseriesReq) -> thrift::Result<TSStatus>;
  fn delete_timeseries(&mut self, session_id: i64, path: Vec<String>) -> thrift::Result<TSStatus>;
  fn delete_storage_groups(&mut self, session_id: i64, storage_group: Vec<String>) -> thrift::Result<TSStatus>;
  fn insert_record(&mut self, req: TSInsertRecordReq) -> thrift::Result<TSStatus>;
  fn insert_string_record(&mut self, req: TSInsertStringRecordReq) -> thrift::Result<TSStatus>;
  fn insert_tablet(&mut self, req: TSInsertTabletReq) -> thrift::Result<TSStatus>;
  fn insert_tablets(&mut self, req: TSInsertTabletsReq) -> thrift::Result<TSStatus>;
  fn insert_records(&mut self, req: TSInsertRecordsReq) -> thrift::Result<TSStatus>;
  fn insert_records_of_one_device(&mut self, req: TSInsertRecordsOfOneDeviceReq) -> thrift::Result<TSStatus>;
  fn insert_string_records(&mut self, req: TSInsertStringRecordsReq) -> thrift::Result<TSStatus>;
  fn test_insert_tablet(&mut self, req: TSInsertTabletReq) -> thrift::Result<TSStatus>;
  fn test_insert_tablets(&mut self, req: TSInsertTabletsReq) -> thrift::Result<TSStatus>;
  fn test_insert_record(&mut self, req: TSInsertRecordReq) -> thrift::Result<TSStatus>;
  fn test_insert_string_record(&mut self, req: TSInsertStringRecordReq) -> thrift::Result<TSStatus>;
  fn test_insert_records(&mut self, req: TSInsertRecordsReq) -> thrift::Result<TSStatus>;
  fn test_insert_records_of_one_device(&mut self, req: TSInsertRecordsOfOneDeviceReq) -> thrift::Result<TSStatus>;
  fn test_insert_string_records(&mut self, req: TSInsertStringRecordsReq) -> thrift::Result<TSStatus>;
  fn delete_data(&mut self, req: TSDeleteDataReq) -> thrift::Result<TSStatus>;
  fn execute_raw_data_query(&mut self, req: TSRawDataQueryReq) -> thrift::Result<TSExecuteStatementResp>;
  fn execute_last_data_query(&mut self, req: TSLastDataQueryReq) -> thrift::Result<TSExecuteStatementResp>;
  fn request_statement_id(&mut self, session_id: i64) -> thrift::Result<i64>;
  fn create_schema_template(&mut self, req: TSCreateSchemaTemplateReq) -> thrift::Result<TSStatus>;
  fn set_schema_template(&mut self, req: TSSetSchemaTemplateReq) -> thrift::Result<TSStatus>;
  fn unset_schema_template(&mut self, req: TSUnsetSchemaTemplateReq) -> thrift::Result<TSStatus>;
}

pub trait TTSIServiceSyncClientMarker {}

pub struct TSIServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> TSIServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> TSIServiceSyncClient<IP, OP> {
    TSIServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for TSIServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TTSIServiceSyncClientMarker for TSIServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TTSIServiceSyncClientMarker> TTSIServiceSyncClient for C {
  fn open_session(&mut self, req: TSOpenSessionReq) -> thrift::Result<TSOpenSessionResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("openSession", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceOpenSessionArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("openSession", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceOpenSessionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn close_session(&mut self, req: TSCloseSessionReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("closeSession", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceCloseSessionArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("closeSession", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceCloseSessionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn execute_statement(&mut self, req: TSExecuteStatementReq) -> thrift::Result<TSExecuteStatementResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("executeStatement", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceExecuteStatementArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("executeStatement", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceExecuteStatementResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn execute_batch_statement(&mut self, req: TSExecuteBatchStatementReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("executeBatchStatement", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceExecuteBatchStatementArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("executeBatchStatement", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceExecuteBatchStatementResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn execute_query_statement(&mut self, req: TSExecuteStatementReq) -> thrift::Result<TSExecuteStatementResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("executeQueryStatement", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceExecuteQueryStatementArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("executeQueryStatement", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceExecuteQueryStatementResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn execute_update_statement(&mut self, req: TSExecuteStatementReq) -> thrift::Result<TSExecuteStatementResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("executeUpdateStatement", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceExecuteUpdateStatementArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("executeUpdateStatement", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceExecuteUpdateStatementResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn fetch_results(&mut self, req: TSFetchResultsReq) -> thrift::Result<TSFetchResultsResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("fetchResults", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceFetchResultsArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("fetchResults", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceFetchResultsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn fetch_metadata(&mut self, req: TSFetchMetadataReq) -> thrift::Result<TSFetchMetadataResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("fetchMetadata", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceFetchMetadataArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("fetchMetadata", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceFetchMetadataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn cancel_operation(&mut self, req: TSCancelOperationReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("cancelOperation", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceCancelOperationArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("cancelOperation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceCancelOperationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn close_operation(&mut self, req: TSCloseOperationReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("closeOperation", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceCloseOperationArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("closeOperation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceCloseOperationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_time_zone(&mut self, session_id: i64) -> thrift::Result<TSGetTimeZoneResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getTimeZone", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceGetTimeZoneArgs { session_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getTimeZone", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceGetTimeZoneResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_time_zone(&mut self, req: TSSetTimeZoneReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("setTimeZone", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceSetTimeZoneArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("setTimeZone", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceSetTimeZoneResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_properties(&mut self) -> thrift::Result<ServerProperties> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("getProperties", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceGetPropertiesArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("getProperties", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceGetPropertiesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_storage_group(&mut self, session_id: i64, storage_group: String) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("setStorageGroup", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceSetStorageGroupArgs { session_id, storage_group };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("setStorageGroup", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceSetStorageGroupResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_timeseries(&mut self, req: TSCreateTimeseriesReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("createTimeseries", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceCreateTimeseriesArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("createTimeseries", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceCreateTimeseriesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_aligned_timeseries(&mut self, req: TSCreateAlignedTimeseriesReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("createAlignedTimeseries", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceCreateAlignedTimeseriesArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("createAlignedTimeseries", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceCreateAlignedTimeseriesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_multi_timeseries(&mut self, req: TSCreateMultiTimeseriesReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("createMultiTimeseries", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceCreateMultiTimeseriesArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("createMultiTimeseries", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceCreateMultiTimeseriesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn delete_timeseries(&mut self, session_id: i64, path: Vec<String>) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("deleteTimeseries", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceDeleteTimeseriesArgs { session_id, path };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("deleteTimeseries", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceDeleteTimeseriesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn delete_storage_groups(&mut self, session_id: i64, storage_group: Vec<String>) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("deleteStorageGroups", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceDeleteStorageGroupsArgs { session_id, storage_group };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("deleteStorageGroups", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceDeleteStorageGroupsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn insert_record(&mut self, req: TSInsertRecordReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("insertRecord", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceInsertRecordArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("insertRecord", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceInsertRecordResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn insert_string_record(&mut self, req: TSInsertStringRecordReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("insertStringRecord", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceInsertStringRecordArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("insertStringRecord", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceInsertStringRecordResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn insert_tablet(&mut self, req: TSInsertTabletReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("insertTablet", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceInsertTabletArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("insertTablet", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceInsertTabletResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn insert_tablets(&mut self, req: TSInsertTabletsReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("insertTablets", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceInsertTabletsArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("insertTablets", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceInsertTabletsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn insert_records(&mut self, req: TSInsertRecordsReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("insertRecords", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceInsertRecordsArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("insertRecords", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceInsertRecordsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn insert_records_of_one_device(&mut self, req: TSInsertRecordsOfOneDeviceReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("insertRecordsOfOneDevice", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceInsertRecordsOfOneDeviceArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("insertRecordsOfOneDevice", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceInsertRecordsOfOneDeviceResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn insert_string_records(&mut self, req: TSInsertStringRecordsReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("insertStringRecords", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceInsertStringRecordsArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("insertStringRecords", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceInsertStringRecordsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn test_insert_tablet(&mut self, req: TSInsertTabletReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("testInsertTablet", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceTestInsertTabletArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("testInsertTablet", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceTestInsertTabletResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn test_insert_tablets(&mut self, req: TSInsertTabletsReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("testInsertTablets", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceTestInsertTabletsArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("testInsertTablets", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceTestInsertTabletsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn test_insert_record(&mut self, req: TSInsertRecordReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("testInsertRecord", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceTestInsertRecordArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("testInsertRecord", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceTestInsertRecordResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn test_insert_string_record(&mut self, req: TSInsertStringRecordReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("testInsertStringRecord", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceTestInsertStringRecordArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("testInsertStringRecord", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceTestInsertStringRecordResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn test_insert_records(&mut self, req: TSInsertRecordsReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("testInsertRecords", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceTestInsertRecordsArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("testInsertRecords", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceTestInsertRecordsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn test_insert_records_of_one_device(&mut self, req: TSInsertRecordsOfOneDeviceReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("testInsertRecordsOfOneDevice", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceTestInsertRecordsOfOneDeviceArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("testInsertRecordsOfOneDevice", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceTestInsertRecordsOfOneDeviceResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn test_insert_string_records(&mut self, req: TSInsertStringRecordsReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("testInsertStringRecords", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceTestInsertStringRecordsArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("testInsertStringRecords", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceTestInsertStringRecordsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn delete_data(&mut self, req: TSDeleteDataReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("deleteData", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceDeleteDataArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("deleteData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceDeleteDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn execute_raw_data_query(&mut self, req: TSRawDataQueryReq) -> thrift::Result<TSExecuteStatementResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("executeRawDataQuery", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceExecuteRawDataQueryArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("executeRawDataQuery", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceExecuteRawDataQueryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn execute_last_data_query(&mut self, req: TSLastDataQueryReq) -> thrift::Result<TSExecuteStatementResp> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("executeLastDataQuery", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceExecuteLastDataQueryArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("executeLastDataQuery", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceExecuteLastDataQueryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn request_statement_id(&mut self, session_id: i64) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("requestStatementId", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceRequestStatementIdArgs { session_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("requestStatementId", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceRequestStatementIdResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn create_schema_template(&mut self, req: TSCreateSchemaTemplateReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("createSchemaTemplate", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceCreateSchemaTemplateArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("createSchemaTemplate", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceCreateSchemaTemplateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_schema_template(&mut self, req: TSSetSchemaTemplateReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("setSchemaTemplate", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceSetSchemaTemplateArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("setSchemaTemplate", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceSetSchemaTemplateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn unset_schema_template(&mut self, req: TSUnsetSchemaTemplateReq) -> thrift::Result<TSStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("unsetSchemaTemplate", TMessageType::Call, self.sequence_number());
        let call_args = TSIServiceUnsetSchemaTemplateArgs { req };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("unsetSchemaTemplate", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = TSIServiceUnsetSchemaTemplateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// TSIService service processor
//

pub trait TSIServiceSyncHandler {
  fn handle_open_session(&self, req: TSOpenSessionReq) -> thrift::Result<TSOpenSessionResp>;
  fn handle_close_session(&self, req: TSCloseSessionReq) -> thrift::Result<TSStatus>;
  fn handle_execute_statement(&self, req: TSExecuteStatementReq) -> thrift::Result<TSExecuteStatementResp>;
  fn handle_execute_batch_statement(&self, req: TSExecuteBatchStatementReq) -> thrift::Result<TSStatus>;
  fn handle_execute_query_statement(&self, req: TSExecuteStatementReq) -> thrift::Result<TSExecuteStatementResp>;
  fn handle_execute_update_statement(&self, req: TSExecuteStatementReq) -> thrift::Result<TSExecuteStatementResp>;
  fn handle_fetch_results(&self, req: TSFetchResultsReq) -> thrift::Result<TSFetchResultsResp>;
  fn handle_fetch_metadata(&self, req: TSFetchMetadataReq) -> thrift::Result<TSFetchMetadataResp>;
  fn handle_cancel_operation(&self, req: TSCancelOperationReq) -> thrift::Result<TSStatus>;
  fn handle_close_operation(&self, req: TSCloseOperationReq) -> thrift::Result<TSStatus>;
  fn handle_get_time_zone(&self, session_id: i64) -> thrift::Result<TSGetTimeZoneResp>;
  fn handle_set_time_zone(&self, req: TSSetTimeZoneReq) -> thrift::Result<TSStatus>;
  fn handle_get_properties(&self) -> thrift::Result<ServerProperties>;
  fn handle_set_storage_group(&self, session_id: i64, storage_group: String) -> thrift::Result<TSStatus>;
  fn handle_create_timeseries(&self, req: TSCreateTimeseriesReq) -> thrift::Result<TSStatus>;
  fn handle_create_aligned_timeseries(&self, req: TSCreateAlignedTimeseriesReq) -> thrift::Result<TSStatus>;
  fn handle_create_multi_timeseries(&self, req: TSCreateMultiTimeseriesReq) -> thrift::Result<TSStatus>;
  fn handle_delete_timeseries(&self, session_id: i64, path: Vec<String>) -> thrift::Result<TSStatus>;
  fn handle_delete_storage_groups(&self, session_id: i64, storage_group: Vec<String>) -> thrift::Result<TSStatus>;
  fn handle_insert_record(&self, req: TSInsertRecordReq) -> thrift::Result<TSStatus>;
  fn handle_insert_string_record(&self, req: TSInsertStringRecordReq) -> thrift::Result<TSStatus>;
  fn handle_insert_tablet(&self, req: TSInsertTabletReq) -> thrift::Result<TSStatus>;
  fn handle_insert_tablets(&self, req: TSInsertTabletsReq) -> thrift::Result<TSStatus>;
  fn handle_insert_records(&self, req: TSInsertRecordsReq) -> thrift::Result<TSStatus>;
  fn handle_insert_records_of_one_device(&self, req: TSInsertRecordsOfOneDeviceReq) -> thrift::Result<TSStatus>;
  fn handle_insert_string_records(&self, req: TSInsertStringRecordsReq) -> thrift::Result<TSStatus>;
  fn handle_test_insert_tablet(&self, req: TSInsertTabletReq) -> thrift::Result<TSStatus>;
  fn handle_test_insert_tablets(&self, req: TSInsertTabletsReq) -> thrift::Result<TSStatus>;
  fn handle_test_insert_record(&self, req: TSInsertRecordReq) -> thrift::Result<TSStatus>;
  fn handle_test_insert_string_record(&self, req: TSInsertStringRecordReq) -> thrift::Result<TSStatus>;
  fn handle_test_insert_records(&self, req: TSInsertRecordsReq) -> thrift::Result<TSStatus>;
  fn handle_test_insert_records_of_one_device(&self, req: TSInsertRecordsOfOneDeviceReq) -> thrift::Result<TSStatus>;
  fn handle_test_insert_string_records(&self, req: TSInsertStringRecordsReq) -> thrift::Result<TSStatus>;
  fn handle_delete_data(&self, req: TSDeleteDataReq) -> thrift::Result<TSStatus>;
  fn handle_execute_raw_data_query(&self, req: TSRawDataQueryReq) -> thrift::Result<TSExecuteStatementResp>;
  fn handle_execute_last_data_query(&self, req: TSLastDataQueryReq) -> thrift::Result<TSExecuteStatementResp>;
  fn handle_request_statement_id(&self, session_id: i64) -> thrift::Result<i64>;
  fn handle_create_schema_template(&self, req: TSCreateSchemaTemplateReq) -> thrift::Result<TSStatus>;
  fn handle_set_schema_template(&self, req: TSSetSchemaTemplateReq) -> thrift::Result<TSStatus>;
  fn handle_unset_schema_template(&self, req: TSUnsetSchemaTemplateReq) -> thrift::Result<TSStatus>;
}

pub struct TSIServiceSyncProcessor<H: TSIServiceSyncHandler> {
  handler: H,
}

impl <H: TSIServiceSyncHandler> TSIServiceSyncProcessor<H> {
  pub fn new(handler: H) -> TSIServiceSyncProcessor<H> {
    TSIServiceSyncProcessor {
      handler,
    }
  }
  fn process_open_session(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_open_session(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_close_session(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_close_session(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_execute_statement(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_execute_statement(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_execute_batch_statement(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_execute_batch_statement(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_execute_query_statement(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_execute_query_statement(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_execute_update_statement(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_execute_update_statement(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_fetch_results(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_fetch_results(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_fetch_metadata(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_fetch_metadata(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_cancel_operation(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_cancel_operation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_close_operation(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_close_operation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_time_zone(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_get_time_zone(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_time_zone(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_set_time_zone(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_properties(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_get_properties(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_storage_group(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_set_storage_group(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_timeseries(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_create_timeseries(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_aligned_timeseries(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_create_aligned_timeseries(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_multi_timeseries(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_create_multi_timeseries(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_delete_timeseries(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_delete_timeseries(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_delete_storage_groups(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_delete_storage_groups(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_insert_record(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_insert_record(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_insert_string_record(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_insert_string_record(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_insert_tablet(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_insert_tablet(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_insert_tablets(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_insert_tablets(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_insert_records(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_insert_records(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_insert_records_of_one_device(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_insert_records_of_one_device(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_insert_string_records(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_insert_string_records(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_test_insert_tablet(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_test_insert_tablet(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_test_insert_tablets(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_test_insert_tablets(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_test_insert_record(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_test_insert_record(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_test_insert_string_record(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_test_insert_string_record(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_test_insert_records(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_test_insert_records(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_test_insert_records_of_one_device(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_test_insert_records_of_one_device(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_test_insert_string_records(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_test_insert_string_records(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_delete_data(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_delete_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_execute_raw_data_query(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_execute_raw_data_query(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_execute_last_data_query(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_execute_last_data_query(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_request_statement_id(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_request_statement_id(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_create_schema_template(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_create_schema_template(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_schema_template(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_set_schema_template(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_unset_schema_template(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TTSIServiceProcessFunctions::process_unset_schema_template(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TTSIServiceProcessFunctions;

impl TTSIServiceProcessFunctions {
  pub fn process_open_session<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceOpenSessionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_open_session(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("openSession", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceOpenSessionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("openSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("openSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_close_session<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceCloseSessionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_close_session(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("closeSession", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceCloseSessionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("closeSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("closeSession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_execute_statement<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceExecuteStatementArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_execute_statement(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("executeStatement", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceExecuteStatementResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("executeStatement", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("executeStatement", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_execute_batch_statement<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceExecuteBatchStatementArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_execute_batch_statement(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("executeBatchStatement", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceExecuteBatchStatementResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("executeBatchStatement", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("executeBatchStatement", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_execute_query_statement<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceExecuteQueryStatementArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_execute_query_statement(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("executeQueryStatement", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceExecuteQueryStatementResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("executeQueryStatement", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("executeQueryStatement", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_execute_update_statement<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceExecuteUpdateStatementArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_execute_update_statement(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("executeUpdateStatement", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceExecuteUpdateStatementResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("executeUpdateStatement", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("executeUpdateStatement", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_fetch_results<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceFetchResultsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_fetch_results(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("fetchResults", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceFetchResultsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("fetchResults", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("fetchResults", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_fetch_metadata<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceFetchMetadataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_fetch_metadata(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("fetchMetadata", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceFetchMetadataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("fetchMetadata", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("fetchMetadata", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_cancel_operation<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceCancelOperationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_cancel_operation(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("cancelOperation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceCancelOperationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("cancelOperation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("cancelOperation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_close_operation<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceCloseOperationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_close_operation(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("closeOperation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceCloseOperationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("closeOperation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("closeOperation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_time_zone<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceGetTimeZoneArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_time_zone(args.session_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getTimeZone", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceGetTimeZoneResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getTimeZone", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getTimeZone", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_time_zone<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceSetTimeZoneArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_time_zone(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("setTimeZone", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceSetTimeZoneResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("setTimeZone", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("setTimeZone", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_properties<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = TSIServiceGetPropertiesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_properties() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("getProperties", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceGetPropertiesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("getProperties", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("getProperties", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_storage_group<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceSetStorageGroupArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_storage_group(args.session_id, args.storage_group) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("setStorageGroup", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceSetStorageGroupResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("setStorageGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("setStorageGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_timeseries<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceCreateTimeseriesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_timeseries(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("createTimeseries", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceCreateTimeseriesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("createTimeseries", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("createTimeseries", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_aligned_timeseries<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceCreateAlignedTimeseriesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_aligned_timeseries(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("createAlignedTimeseries", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceCreateAlignedTimeseriesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("createAlignedTimeseries", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("createAlignedTimeseries", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_multi_timeseries<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceCreateMultiTimeseriesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_multi_timeseries(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("createMultiTimeseries", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceCreateMultiTimeseriesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("createMultiTimeseries", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("createMultiTimeseries", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_delete_timeseries<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceDeleteTimeseriesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_delete_timeseries(args.session_id, args.path) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("deleteTimeseries", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceDeleteTimeseriesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("deleteTimeseries", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("deleteTimeseries", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_delete_storage_groups<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceDeleteStorageGroupsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_delete_storage_groups(args.session_id, args.storage_group) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("deleteStorageGroups", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceDeleteStorageGroupsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("deleteStorageGroups", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("deleteStorageGroups", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_insert_record<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceInsertRecordArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_insert_record(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("insertRecord", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceInsertRecordResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("insertRecord", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("insertRecord", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_insert_string_record<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceInsertStringRecordArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_insert_string_record(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("insertStringRecord", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceInsertStringRecordResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("insertStringRecord", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("insertStringRecord", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_insert_tablet<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceInsertTabletArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_insert_tablet(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("insertTablet", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceInsertTabletResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("insertTablet", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("insertTablet", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_insert_tablets<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceInsertTabletsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_insert_tablets(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("insertTablets", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceInsertTabletsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("insertTablets", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("insertTablets", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_insert_records<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceInsertRecordsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_insert_records(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("insertRecords", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceInsertRecordsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("insertRecords", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("insertRecords", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_insert_records_of_one_device<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceInsertRecordsOfOneDeviceArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_insert_records_of_one_device(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("insertRecordsOfOneDevice", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceInsertRecordsOfOneDeviceResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("insertRecordsOfOneDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("insertRecordsOfOneDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_insert_string_records<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceInsertStringRecordsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_insert_string_records(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("insertStringRecords", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceInsertStringRecordsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("insertStringRecords", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("insertStringRecords", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_test_insert_tablet<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceTestInsertTabletArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_test_insert_tablet(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("testInsertTablet", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceTestInsertTabletResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("testInsertTablet", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("testInsertTablet", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_test_insert_tablets<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceTestInsertTabletsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_test_insert_tablets(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("testInsertTablets", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceTestInsertTabletsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("testInsertTablets", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("testInsertTablets", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_test_insert_record<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceTestInsertRecordArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_test_insert_record(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("testInsertRecord", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceTestInsertRecordResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("testInsertRecord", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("testInsertRecord", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_test_insert_string_record<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceTestInsertStringRecordArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_test_insert_string_record(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("testInsertStringRecord", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceTestInsertStringRecordResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("testInsertStringRecord", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("testInsertStringRecord", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_test_insert_records<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceTestInsertRecordsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_test_insert_records(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("testInsertRecords", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceTestInsertRecordsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("testInsertRecords", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("testInsertRecords", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_test_insert_records_of_one_device<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceTestInsertRecordsOfOneDeviceArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_test_insert_records_of_one_device(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("testInsertRecordsOfOneDevice", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceTestInsertRecordsOfOneDeviceResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("testInsertRecordsOfOneDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("testInsertRecordsOfOneDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_test_insert_string_records<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceTestInsertStringRecordsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_test_insert_string_records(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("testInsertStringRecords", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceTestInsertStringRecordsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("testInsertStringRecords", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("testInsertStringRecords", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_delete_data<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceDeleteDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_delete_data(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("deleteData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceDeleteDataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("deleteData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("deleteData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_execute_raw_data_query<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceExecuteRawDataQueryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_execute_raw_data_query(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("executeRawDataQuery", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceExecuteRawDataQueryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("executeRawDataQuery", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("executeRawDataQuery", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_execute_last_data_query<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceExecuteLastDataQueryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_execute_last_data_query(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("executeLastDataQuery", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceExecuteLastDataQueryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("executeLastDataQuery", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("executeLastDataQuery", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_request_statement_id<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceRequestStatementIdArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_request_statement_id(args.session_id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("requestStatementId", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceRequestStatementIdResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("requestStatementId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("requestStatementId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_create_schema_template<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceCreateSchemaTemplateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_create_schema_template(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("createSchemaTemplate", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceCreateSchemaTemplateResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("createSchemaTemplate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("createSchemaTemplate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_schema_template<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceSetSchemaTemplateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_schema_template(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("setSchemaTemplate", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceSetSchemaTemplateResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("setSchemaTemplate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("setSchemaTemplate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_unset_schema_template<H: TSIServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = TSIServiceUnsetSchemaTemplateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_unset_schema_template(args.req) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("unsetSchemaTemplate", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = TSIServiceUnsetSchemaTemplateResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("unsetSchemaTemplate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("unsetSchemaTemplate", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: TSIServiceSyncHandler> TProcessor for TSIServiceSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "openSession" => {
        self.process_open_session(message_ident.sequence_number, i_prot, o_prot)
      },
      "closeSession" => {
        self.process_close_session(message_ident.sequence_number, i_prot, o_prot)
      },
      "executeStatement" => {
        self.process_execute_statement(message_ident.sequence_number, i_prot, o_prot)
      },
      "executeBatchStatement" => {
        self.process_execute_batch_statement(message_ident.sequence_number, i_prot, o_prot)
      },
      "executeQueryStatement" => {
        self.process_execute_query_statement(message_ident.sequence_number, i_prot, o_prot)
      },
      "executeUpdateStatement" => {
        self.process_execute_update_statement(message_ident.sequence_number, i_prot, o_prot)
      },
      "fetchResults" => {
        self.process_fetch_results(message_ident.sequence_number, i_prot, o_prot)
      },
      "fetchMetadata" => {
        self.process_fetch_metadata(message_ident.sequence_number, i_prot, o_prot)
      },
      "cancelOperation" => {
        self.process_cancel_operation(message_ident.sequence_number, i_prot, o_prot)
      },
      "closeOperation" => {
        self.process_close_operation(message_ident.sequence_number, i_prot, o_prot)
      },
      "getTimeZone" => {
        self.process_get_time_zone(message_ident.sequence_number, i_prot, o_prot)
      },
      "setTimeZone" => {
        self.process_set_time_zone(message_ident.sequence_number, i_prot, o_prot)
      },
      "getProperties" => {
        self.process_get_properties(message_ident.sequence_number, i_prot, o_prot)
      },
      "setStorageGroup" => {
        self.process_set_storage_group(message_ident.sequence_number, i_prot, o_prot)
      },
      "createTimeseries" => {
        self.process_create_timeseries(message_ident.sequence_number, i_prot, o_prot)
      },
      "createAlignedTimeseries" => {
        self.process_create_aligned_timeseries(message_ident.sequence_number, i_prot, o_prot)
      },
      "createMultiTimeseries" => {
        self.process_create_multi_timeseries(message_ident.sequence_number, i_prot, o_prot)
      },
      "deleteTimeseries" => {
        self.process_delete_timeseries(message_ident.sequence_number, i_prot, o_prot)
      },
      "deleteStorageGroups" => {
        self.process_delete_storage_groups(message_ident.sequence_number, i_prot, o_prot)
      },
      "insertRecord" => {
        self.process_insert_record(message_ident.sequence_number, i_prot, o_prot)
      },
      "insertStringRecord" => {
        self.process_insert_string_record(message_ident.sequence_number, i_prot, o_prot)
      },
      "insertTablet" => {
        self.process_insert_tablet(message_ident.sequence_number, i_prot, o_prot)
      },
      "insertTablets" => {
        self.process_insert_tablets(message_ident.sequence_number, i_prot, o_prot)
      },
      "insertRecords" => {
        self.process_insert_records(message_ident.sequence_number, i_prot, o_prot)
      },
      "insertRecordsOfOneDevice" => {
        self.process_insert_records_of_one_device(message_ident.sequence_number, i_prot, o_prot)
      },
      "insertStringRecords" => {
        self.process_insert_string_records(message_ident.sequence_number, i_prot, o_prot)
      },
      "testInsertTablet" => {
        self.process_test_insert_tablet(message_ident.sequence_number, i_prot, o_prot)
      },
      "testInsertTablets" => {
        self.process_test_insert_tablets(message_ident.sequence_number, i_prot, o_prot)
      },
      "testInsertRecord" => {
        self.process_test_insert_record(message_ident.sequence_number, i_prot, o_prot)
      },
      "testInsertStringRecord" => {
        self.process_test_insert_string_record(message_ident.sequence_number, i_prot, o_prot)
      },
      "testInsertRecords" => {
        self.process_test_insert_records(message_ident.sequence_number, i_prot, o_prot)
      },
      "testInsertRecordsOfOneDevice" => {
        self.process_test_insert_records_of_one_device(message_ident.sequence_number, i_prot, o_prot)
      },
      "testInsertStringRecords" => {
        self.process_test_insert_string_records(message_ident.sequence_number, i_prot, o_prot)
      },
      "deleteData" => {
        self.process_delete_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "executeRawDataQuery" => {
        self.process_execute_raw_data_query(message_ident.sequence_number, i_prot, o_prot)
      },
      "executeLastDataQuery" => {
        self.process_execute_last_data_query(message_ident.sequence_number, i_prot, o_prot)
      },
      "requestStatementId" => {
        self.process_request_statement_id(message_ident.sequence_number, i_prot, o_prot)
      },
      "createSchemaTemplate" => {
        self.process_create_schema_template(message_ident.sequence_number, i_prot, o_prot)
      },
      "setSchemaTemplate" => {
        self.process_set_schema_template(message_ident.sequence_number, i_prot, o_prot)
      },
      "unsetSchemaTemplate" => {
        self.process_unset_schema_template(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// TSIServiceOpenSessionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceOpenSessionArgs {
  req: TSOpenSessionReq,
}

impl TSIServiceOpenSessionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceOpenSessionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSOpenSessionReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSOpenSessionReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceOpenSessionArgs.req", &f_1)?;
    let ret = TSIServiceOpenSessionArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("openSession_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceOpenSessionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceOpenSessionResult {
  result_value: Option<TSOpenSessionResp>,
}

impl TSIServiceOpenSessionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceOpenSessionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSOpenSessionResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSOpenSessionResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceOpenSessionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceOpenSessionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSOpenSessionResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceOpenSession"
          )
        )
      )
    }
  }
}

//
// TSIServiceCloseSessionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceCloseSessionArgs {
  req: TSCloseSessionReq,
}

impl TSIServiceCloseSessionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceCloseSessionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSCloseSessionReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSCloseSessionReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceCloseSessionArgs.req", &f_1)?;
    let ret = TSIServiceCloseSessionArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("closeSession_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceCloseSessionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceCloseSessionResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceCloseSessionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceCloseSessionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceCloseSessionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceCloseSessionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceCloseSession"
          )
        )
      )
    }
  }
}

//
// TSIServiceExecuteStatementArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceExecuteStatementArgs {
  req: TSExecuteStatementReq,
}

impl TSIServiceExecuteStatementArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceExecuteStatementArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSExecuteStatementReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSExecuteStatementReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceExecuteStatementArgs.req", &f_1)?;
    let ret = TSIServiceExecuteStatementArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("executeStatement_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceExecuteStatementResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceExecuteStatementResult {
  result_value: Option<TSExecuteStatementResp>,
}

impl TSIServiceExecuteStatementResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceExecuteStatementResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSExecuteStatementResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSExecuteStatementResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceExecuteStatementResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceExecuteStatementResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSExecuteStatementResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceExecuteStatement"
          )
        )
      )
    }
  }
}

//
// TSIServiceExecuteBatchStatementArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceExecuteBatchStatementArgs {
  req: TSExecuteBatchStatementReq,
}

impl TSIServiceExecuteBatchStatementArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceExecuteBatchStatementArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSExecuteBatchStatementReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSExecuteBatchStatementReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceExecuteBatchStatementArgs.req", &f_1)?;
    let ret = TSIServiceExecuteBatchStatementArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("executeBatchStatement_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceExecuteBatchStatementResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceExecuteBatchStatementResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceExecuteBatchStatementResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceExecuteBatchStatementResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceExecuteBatchStatementResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceExecuteBatchStatementResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceExecuteBatchStatement"
          )
        )
      )
    }
  }
}

//
// TSIServiceExecuteQueryStatementArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceExecuteQueryStatementArgs {
  req: TSExecuteStatementReq,
}

impl TSIServiceExecuteQueryStatementArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceExecuteQueryStatementArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSExecuteStatementReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSExecuteStatementReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceExecuteQueryStatementArgs.req", &f_1)?;
    let ret = TSIServiceExecuteQueryStatementArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("executeQueryStatement_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceExecuteQueryStatementResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceExecuteQueryStatementResult {
  result_value: Option<TSExecuteStatementResp>,
}

impl TSIServiceExecuteQueryStatementResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceExecuteQueryStatementResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSExecuteStatementResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSExecuteStatementResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceExecuteQueryStatementResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceExecuteQueryStatementResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSExecuteStatementResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceExecuteQueryStatement"
          )
        )
      )
    }
  }
}

//
// TSIServiceExecuteUpdateStatementArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceExecuteUpdateStatementArgs {
  req: TSExecuteStatementReq,
}

impl TSIServiceExecuteUpdateStatementArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceExecuteUpdateStatementArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSExecuteStatementReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSExecuteStatementReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceExecuteUpdateStatementArgs.req", &f_1)?;
    let ret = TSIServiceExecuteUpdateStatementArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("executeUpdateStatement_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceExecuteUpdateStatementResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceExecuteUpdateStatementResult {
  result_value: Option<TSExecuteStatementResp>,
}

impl TSIServiceExecuteUpdateStatementResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceExecuteUpdateStatementResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSExecuteStatementResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSExecuteStatementResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceExecuteUpdateStatementResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceExecuteUpdateStatementResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSExecuteStatementResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceExecuteUpdateStatement"
          )
        )
      )
    }
  }
}

//
// TSIServiceFetchResultsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceFetchResultsArgs {
  req: TSFetchResultsReq,
}

impl TSIServiceFetchResultsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceFetchResultsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSFetchResultsReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSFetchResultsReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceFetchResultsArgs.req", &f_1)?;
    let ret = TSIServiceFetchResultsArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("fetchResults_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceFetchResultsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceFetchResultsResult {
  result_value: Option<TSFetchResultsResp>,
}

impl TSIServiceFetchResultsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceFetchResultsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSFetchResultsResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSFetchResultsResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceFetchResultsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceFetchResultsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSFetchResultsResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceFetchsResult"
          )
        )
      )
    }
  }
}

//
// TSIServiceFetchMetadataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceFetchMetadataArgs {
  req: TSFetchMetadataReq,
}

impl TSIServiceFetchMetadataArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceFetchMetadataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSFetchMetadataReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSFetchMetadataReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceFetchMetadataArgs.req", &f_1)?;
    let ret = TSIServiceFetchMetadataArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("fetchMetadata_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceFetchMetadataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceFetchMetadataResult {
  result_value: Option<TSFetchMetadataResp>,
}

impl TSIServiceFetchMetadataResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceFetchMetadataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSFetchMetadataResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSFetchMetadataResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceFetchMetadataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceFetchMetadataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSFetchMetadataResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceFetchMetadata"
          )
        )
      )
    }
  }
}

//
// TSIServiceCancelOperationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceCancelOperationArgs {
  req: TSCancelOperationReq,
}

impl TSIServiceCancelOperationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceCancelOperationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSCancelOperationReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSCancelOperationReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceCancelOperationArgs.req", &f_1)?;
    let ret = TSIServiceCancelOperationArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("cancelOperation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceCancelOperationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceCancelOperationResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceCancelOperationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceCancelOperationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceCancelOperationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceCancelOperationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceCancelOperation"
          )
        )
      )
    }
  }
}

//
// TSIServiceCloseOperationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceCloseOperationArgs {
  req: TSCloseOperationReq,
}

impl TSIServiceCloseOperationArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceCloseOperationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSCloseOperationReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSCloseOperationReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceCloseOperationArgs.req", &f_1)?;
    let ret = TSIServiceCloseOperationArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("closeOperation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceCloseOperationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceCloseOperationResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceCloseOperationResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceCloseOperationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceCloseOperationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceCloseOperationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceCloseOperation"
          )
        )
      )
    }
  }
}

//
// TSIServiceGetTimeZoneArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceGetTimeZoneArgs {
  session_id: i64,
}

impl TSIServiceGetTimeZoneArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceGetTimeZoneArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceGetTimeZoneArgs.session_id", &f_1)?;
    let ret = TSIServiceGetTimeZoneArgs {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getTimeZone_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceGetTimeZoneResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceGetTimeZoneResult {
  result_value: Option<TSGetTimeZoneResp>,
}

impl TSIServiceGetTimeZoneResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceGetTimeZoneResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSGetTimeZoneResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSGetTimeZoneResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceGetTimeZoneResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceGetTimeZoneResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSGetTimeZoneResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceGetTimeZone"
          )
        )
      )
    }
  }
}

//
// TSIServiceSetTimeZoneArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceSetTimeZoneArgs {
  req: TSSetTimeZoneReq,
}

impl TSIServiceSetTimeZoneArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceSetTimeZoneArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSSetTimeZoneReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSSetTimeZoneReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceSetTimeZoneArgs.req", &f_1)?;
    let ret = TSIServiceSetTimeZoneArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("setTimeZone_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceSetTimeZoneResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceSetTimeZoneResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceSetTimeZoneResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceSetTimeZoneResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceSetTimeZoneResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceSetTimeZoneResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceSetTimeZone"
          )
        )
      )
    }
  }
}

//
// TSIServiceGetPropertiesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceGetPropertiesArgs {
}

impl TSIServiceGetPropertiesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceGetPropertiesArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceGetPropertiesArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("getProperties_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceGetPropertiesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceGetPropertiesResult {
  result_value: Option<ServerProperties>,
}

impl TSIServiceGetPropertiesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceGetPropertiesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<ServerProperties> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = ServerProperties::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceGetPropertiesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceGetPropertiesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<ServerProperties> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceGetProperties"
          )
        )
      )
    }
  }
}

//
// TSIServiceSetStorageGroupArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceSetStorageGroupArgs {
  session_id: i64,
  storage_group: String,
}

impl TSIServiceSetStorageGroupArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceSetStorageGroupArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceSetStorageGroupArgs.session_id", &f_1)?;
    verify_required_field_exists("TSIServiceSetStorageGroupArgs.storage_group", &f_2)?;
    let ret = TSIServiceSetStorageGroupArgs {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      storage_group: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("setStorageGroup_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("storageGroup", TType::String, 2))?;
    o_prot.write_string(&self.storage_group)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceSetStorageGroupResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceSetStorageGroupResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceSetStorageGroupResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceSetStorageGroupResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceSetStorageGroupResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceSetStorageGroupResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceSetStorageGroup"
          )
        )
      )
    }
  }
}

//
// TSIServiceCreateTimeseriesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceCreateTimeseriesArgs {
  req: TSCreateTimeseriesReq,
}

impl TSIServiceCreateTimeseriesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceCreateTimeseriesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSCreateTimeseriesReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSCreateTimeseriesReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceCreateTimeseriesArgs.req", &f_1)?;
    let ret = TSIServiceCreateTimeseriesArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("createTimeseries_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceCreateTimeseriesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceCreateTimeseriesResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceCreateTimeseriesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceCreateTimeseriesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceCreateTimeseriesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceCreateTimeseriesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceCreateTimeseries"
          )
        )
      )
    }
  }
}

//
// TSIServiceCreateAlignedTimeseriesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceCreateAlignedTimeseriesArgs {
  req: TSCreateAlignedTimeseriesReq,
}

impl TSIServiceCreateAlignedTimeseriesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceCreateAlignedTimeseriesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSCreateAlignedTimeseriesReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSCreateAlignedTimeseriesReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceCreateAlignedTimeseriesArgs.req", &f_1)?;
    let ret = TSIServiceCreateAlignedTimeseriesArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("createAlignedTimeseries_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceCreateAlignedTimeseriesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceCreateAlignedTimeseriesResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceCreateAlignedTimeseriesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceCreateAlignedTimeseriesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceCreateAlignedTimeseriesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceCreateAlignedTimeseriesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceCreateAlignedTimeseries"
          )
        )
      )
    }
  }
}

//
// TSIServiceCreateMultiTimeseriesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceCreateMultiTimeseriesArgs {
  req: TSCreateMultiTimeseriesReq,
}

impl TSIServiceCreateMultiTimeseriesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceCreateMultiTimeseriesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSCreateMultiTimeseriesReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSCreateMultiTimeseriesReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceCreateMultiTimeseriesArgs.req", &f_1)?;
    let ret = TSIServiceCreateMultiTimeseriesArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("createMultiTimeseries_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceCreateMultiTimeseriesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceCreateMultiTimeseriesResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceCreateMultiTimeseriesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceCreateMultiTimeseriesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceCreateMultiTimeseriesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceCreateMultiTimeseriesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceCreateMultiTimeseries"
          )
        )
      )
    }
  }
}

//
// TSIServiceDeleteTimeseriesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceDeleteTimeseriesArgs {
  session_id: i64,
  path: Vec<String>,
}

impl TSIServiceDeleteTimeseriesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceDeleteTimeseriesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_83 = i_prot.read_string()?;
            val.push(list_elem_83);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceDeleteTimeseriesArgs.session_id", &f_1)?;
    verify_required_field_exists("TSIServiceDeleteTimeseriesArgs.path", &f_2)?;
    let ret = TSIServiceDeleteTimeseriesArgs {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      path: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("deleteTimeseries_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("path", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.path.len() as i32))?;
    for e in &self.path {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceDeleteTimeseriesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceDeleteTimeseriesResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceDeleteTimeseriesResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceDeleteTimeseriesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceDeleteTimeseriesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceDeleteTimeseriesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceDeleteTimeseries"
          )
        )
      )
    }
  }
}

//
// TSIServiceDeleteStorageGroupsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceDeleteStorageGroupsArgs {
  session_id: i64,
  storage_group: Vec<String>,
}

impl TSIServiceDeleteStorageGroupsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceDeleteStorageGroupsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_84 = i_prot.read_string()?;
            val.push(list_elem_84);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceDeleteStorageGroupsArgs.session_id", &f_1)?;
    verify_required_field_exists("TSIServiceDeleteStorageGroupsArgs.storage_group", &f_2)?;
    let ret = TSIServiceDeleteStorageGroupsArgs {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      storage_group: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("deleteStorageGroups_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("storageGroup", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.storage_group.len() as i32))?;
    for e in &self.storage_group {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceDeleteStorageGroupsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceDeleteStorageGroupsResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceDeleteStorageGroupsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceDeleteStorageGroupsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceDeleteStorageGroupsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceDeleteStorageGroupsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceDeleteStorageGroups"
          )
        )
      )
    }
  }
}

//
// TSIServiceInsertRecordArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceInsertRecordArgs {
  req: TSInsertRecordReq,
}

impl TSIServiceInsertRecordArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceInsertRecordArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertRecordReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertRecordReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceInsertRecordArgs.req", &f_1)?;
    let ret = TSIServiceInsertRecordArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("insertRecord_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceInsertRecordResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceInsertRecordResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceInsertRecordResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceInsertRecordResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceInsertRecordResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceInsertRecordResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceInsertRecord"
          )
        )
      )
    }
  }
}

//
// TSIServiceInsertStringRecordArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceInsertStringRecordArgs {
  req: TSInsertStringRecordReq,
}

impl TSIServiceInsertStringRecordArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceInsertStringRecordArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertStringRecordReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertStringRecordReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceInsertStringRecordArgs.req", &f_1)?;
    let ret = TSIServiceInsertStringRecordArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("insertStringRecord_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceInsertStringRecordResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceInsertStringRecordResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceInsertStringRecordResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceInsertStringRecordResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceInsertStringRecordResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceInsertStringRecordResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceInsertStringRecord"
          )
        )
      )
    }
  }
}

//
// TSIServiceInsertTabletArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceInsertTabletArgs {
  req: TSInsertTabletReq,
}

impl TSIServiceInsertTabletArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceInsertTabletArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertTabletReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertTabletReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceInsertTabletArgs.req", &f_1)?;
    let ret = TSIServiceInsertTabletArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("insertTablet_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceInsertTabletResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceInsertTabletResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceInsertTabletResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceInsertTabletResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceInsertTabletResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceInsertTabletResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceInsertTablet"
          )
        )
      )
    }
  }
}

//
// TSIServiceInsertTabletsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceInsertTabletsArgs {
  req: TSInsertTabletsReq,
}

impl TSIServiceInsertTabletsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceInsertTabletsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertTabletsReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertTabletsReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceInsertTabletsArgs.req", &f_1)?;
    let ret = TSIServiceInsertTabletsArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("insertTablets_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceInsertTabletsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceInsertTabletsResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceInsertTabletsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceInsertTabletsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceInsertTabletsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceInsertTabletsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceInsertTablets"
          )
        )
      )
    }
  }
}

//
// TSIServiceInsertRecordsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceInsertRecordsArgs {
  req: TSInsertRecordsReq,
}

impl TSIServiceInsertRecordsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceInsertRecordsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertRecordsReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertRecordsReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceInsertRecordsArgs.req", &f_1)?;
    let ret = TSIServiceInsertRecordsArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("insertRecords_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceInsertRecordsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceInsertRecordsResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceInsertRecordsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceInsertRecordsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceInsertRecordsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceInsertRecordsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceInsertRecords"
          )
        )
      )
    }
  }
}

//
// TSIServiceInsertRecordsOfOneDeviceArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceInsertRecordsOfOneDeviceArgs {
  req: TSInsertRecordsOfOneDeviceReq,
}

impl TSIServiceInsertRecordsOfOneDeviceArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceInsertRecordsOfOneDeviceArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertRecordsOfOneDeviceReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertRecordsOfOneDeviceReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceInsertRecordsOfOneDeviceArgs.req", &f_1)?;
    let ret = TSIServiceInsertRecordsOfOneDeviceArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("insertRecordsOfOneDevice_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceInsertRecordsOfOneDeviceResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceInsertRecordsOfOneDeviceResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceInsertRecordsOfOneDeviceResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceInsertRecordsOfOneDeviceResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceInsertRecordsOfOneDeviceResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceInsertRecordsOfOneDeviceResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceInsertRecordsOfOneDevice"
          )
        )
      )
    }
  }
}

//
// TSIServiceInsertStringRecordsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceInsertStringRecordsArgs {
  req: TSInsertStringRecordsReq,
}

impl TSIServiceInsertStringRecordsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceInsertStringRecordsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertStringRecordsReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertStringRecordsReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceInsertStringRecordsArgs.req", &f_1)?;
    let ret = TSIServiceInsertStringRecordsArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("insertStringRecords_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceInsertStringRecordsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceInsertStringRecordsResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceInsertStringRecordsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceInsertStringRecordsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceInsertStringRecordsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceInsertStringRecordsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceInsertStringRecords"
          )
        )
      )
    }
  }
}

//
// TSIServiceTestInsertTabletArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceTestInsertTabletArgs {
  req: TSInsertTabletReq,
}

impl TSIServiceTestInsertTabletArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceTestInsertTabletArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertTabletReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertTabletReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceTestInsertTabletArgs.req", &f_1)?;
    let ret = TSIServiceTestInsertTabletArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("testInsertTablet_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceTestInsertTabletResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceTestInsertTabletResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceTestInsertTabletResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceTestInsertTabletResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceTestInsertTabletResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceTestInsertTabletResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceTestInsertTablet"
          )
        )
      )
    }
  }
}

//
// TSIServiceTestInsertTabletsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceTestInsertTabletsArgs {
  req: TSInsertTabletsReq,
}

impl TSIServiceTestInsertTabletsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceTestInsertTabletsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertTabletsReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertTabletsReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceTestInsertTabletsArgs.req", &f_1)?;
    let ret = TSIServiceTestInsertTabletsArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("testInsertTablets_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceTestInsertTabletsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceTestInsertTabletsResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceTestInsertTabletsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceTestInsertTabletsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceTestInsertTabletsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceTestInsertTabletsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceTestInsertTablets"
          )
        )
      )
    }
  }
}

//
// TSIServiceTestInsertRecordArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceTestInsertRecordArgs {
  req: TSInsertRecordReq,
}

impl TSIServiceTestInsertRecordArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceTestInsertRecordArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertRecordReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertRecordReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceTestInsertRecordArgs.req", &f_1)?;
    let ret = TSIServiceTestInsertRecordArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("testInsertRecord_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceTestInsertRecordResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceTestInsertRecordResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceTestInsertRecordResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceTestInsertRecordResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceTestInsertRecordResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceTestInsertRecordResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceTestInsertRecord"
          )
        )
      )
    }
  }
}

//
// TSIServiceTestInsertStringRecordArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceTestInsertStringRecordArgs {
  req: TSInsertStringRecordReq,
}

impl TSIServiceTestInsertStringRecordArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceTestInsertStringRecordArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertStringRecordReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertStringRecordReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceTestInsertStringRecordArgs.req", &f_1)?;
    let ret = TSIServiceTestInsertStringRecordArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("testInsertStringRecord_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceTestInsertStringRecordResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceTestInsertStringRecordResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceTestInsertStringRecordResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceTestInsertStringRecordResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceTestInsertStringRecordResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceTestInsertStringRecordResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceTestInsertStringRecord"
          )
        )
      )
    }
  }
}

//
// TSIServiceTestInsertRecordsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceTestInsertRecordsArgs {
  req: TSInsertRecordsReq,
}

impl TSIServiceTestInsertRecordsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceTestInsertRecordsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertRecordsReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertRecordsReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceTestInsertRecordsArgs.req", &f_1)?;
    let ret = TSIServiceTestInsertRecordsArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("testInsertRecords_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceTestInsertRecordsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceTestInsertRecordsResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceTestInsertRecordsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceTestInsertRecordsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceTestInsertRecordsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceTestInsertRecordsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceTestInsertRecords"
          )
        )
      )
    }
  }
}

//
// TSIServiceTestInsertRecordsOfOneDeviceArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceTestInsertRecordsOfOneDeviceArgs {
  req: TSInsertRecordsOfOneDeviceReq,
}

impl TSIServiceTestInsertRecordsOfOneDeviceArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceTestInsertRecordsOfOneDeviceArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertRecordsOfOneDeviceReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertRecordsOfOneDeviceReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceTestInsertRecordsOfOneDeviceArgs.req", &f_1)?;
    let ret = TSIServiceTestInsertRecordsOfOneDeviceArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("testInsertRecordsOfOneDevice_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceTestInsertRecordsOfOneDeviceResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceTestInsertRecordsOfOneDeviceResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceTestInsertRecordsOfOneDeviceResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceTestInsertRecordsOfOneDeviceResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceTestInsertRecordsOfOneDeviceResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceTestInsertRecordsOfOneDeviceResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceTestInsertRecordsOfOneDevice"
          )
        )
      )
    }
  }
}

//
// TSIServiceTestInsertStringRecordsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceTestInsertStringRecordsArgs {
  req: TSInsertStringRecordsReq,
}

impl TSIServiceTestInsertStringRecordsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceTestInsertStringRecordsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSInsertStringRecordsReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSInsertStringRecordsReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceTestInsertStringRecordsArgs.req", &f_1)?;
    let ret = TSIServiceTestInsertStringRecordsArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("testInsertStringRecords_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceTestInsertStringRecordsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceTestInsertStringRecordsResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceTestInsertStringRecordsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceTestInsertStringRecordsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceTestInsertStringRecordsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceTestInsertStringRecordsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceTestInsertStringRecords"
          )
        )
      )
    }
  }
}

//
// TSIServiceDeleteDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceDeleteDataArgs {
  req: TSDeleteDataReq,
}

impl TSIServiceDeleteDataArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceDeleteDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSDeleteDataReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSDeleteDataReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceDeleteDataArgs.req", &f_1)?;
    let ret = TSIServiceDeleteDataArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("deleteData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceDeleteDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceDeleteDataResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceDeleteDataResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceDeleteDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceDeleteDataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceDeleteDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceDeleteData"
          )
        )
      )
    }
  }
}

//
// TSIServiceExecuteRawDataQueryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceExecuteRawDataQueryArgs {
  req: TSRawDataQueryReq,
}

impl TSIServiceExecuteRawDataQueryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceExecuteRawDataQueryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSRawDataQueryReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSRawDataQueryReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceExecuteRawDataQueryArgs.req", &f_1)?;
    let ret = TSIServiceExecuteRawDataQueryArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("executeRawDataQuery_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceExecuteRawDataQueryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceExecuteRawDataQueryResult {
  result_value: Option<TSExecuteStatementResp>,
}

impl TSIServiceExecuteRawDataQueryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceExecuteRawDataQueryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSExecuteStatementResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSExecuteStatementResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceExecuteRawDataQueryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceExecuteRawDataQueryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSExecuteStatementResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceExecuteRawDataQuery"
          )
        )
      )
    }
  }
}

//
// TSIServiceExecuteLastDataQueryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceExecuteLastDataQueryArgs {
  req: TSLastDataQueryReq,
}

impl TSIServiceExecuteLastDataQueryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceExecuteLastDataQueryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSLastDataQueryReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSLastDataQueryReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceExecuteLastDataQueryArgs.req", &f_1)?;
    let ret = TSIServiceExecuteLastDataQueryArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("executeLastDataQuery_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceExecuteLastDataQueryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceExecuteLastDataQueryResult {
  result_value: Option<TSExecuteStatementResp>,
}

impl TSIServiceExecuteLastDataQueryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceExecuteLastDataQueryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSExecuteStatementResp> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSExecuteStatementResp::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceExecuteLastDataQueryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceExecuteLastDataQueryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSExecuteStatementResp> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceExecuteLastDataQuery"
          )
        )
      )
    }
  }
}

//
// TSIServiceRequestStatementIdArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceRequestStatementIdArgs {
  session_id: i64,
}

impl TSIServiceRequestStatementIdArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceRequestStatementIdArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceRequestStatementIdArgs.session_id", &f_1)?;
    let ret = TSIServiceRequestStatementIdArgs {
      session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("requestStatementId_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sessionId", TType::I64, 1))?;
    o_prot.write_i64(self.session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceRequestStatementIdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceRequestStatementIdResult {
  result_value: Option<i64>,
}

impl TSIServiceRequestStatementIdResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceRequestStatementIdResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceRequestStatementIdResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceRequestStatementIdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceRequestStatementId"
          )
        )
      )
    }
  }
}

//
// TSIServiceCreateSchemaTemplateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceCreateSchemaTemplateArgs {
  req: TSCreateSchemaTemplateReq,
}

impl TSIServiceCreateSchemaTemplateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceCreateSchemaTemplateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSCreateSchemaTemplateReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSCreateSchemaTemplateReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceCreateSchemaTemplateArgs.req", &f_1)?;
    let ret = TSIServiceCreateSchemaTemplateArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("createSchemaTemplate_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceCreateSchemaTemplateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceCreateSchemaTemplateResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceCreateSchemaTemplateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceCreateSchemaTemplateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceCreateSchemaTemplateResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceCreateSchemaTemplateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceCreateSchemaTemplate"
          )
        )
      )
    }
  }
}

//
// TSIServiceSetSchemaTemplateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceSetSchemaTemplateArgs {
  req: TSSetSchemaTemplateReq,
}

impl TSIServiceSetSchemaTemplateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceSetSchemaTemplateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSSetSchemaTemplateReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSSetSchemaTemplateReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceSetSchemaTemplateArgs.req", &f_1)?;
    let ret = TSIServiceSetSchemaTemplateArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("setSchemaTemplate_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceSetSchemaTemplateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceSetSchemaTemplateResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceSetSchemaTemplateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceSetSchemaTemplateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceSetSchemaTemplateResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceSetSchemaTemplateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceSetSchemaTemplate"
          )
        )
      )
    }
  }
}

//
// TSIServiceUnsetSchemaTemplateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceUnsetSchemaTemplateArgs {
  req: TSUnsetSchemaTemplateReq,
}

impl TSIServiceUnsetSchemaTemplateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceUnsetSchemaTemplateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<TSUnsetSchemaTemplateReq> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = TSUnsetSchemaTemplateReq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TSIServiceUnsetSchemaTemplateArgs.req", &f_1)?;
    let ret = TSIServiceUnsetSchemaTemplateArgs {
      req: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("unsetSchemaTemplate_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("req", TType::Struct, 1))?;
    self.req.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TSIServiceUnsetSchemaTemplateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct TSIServiceUnsetSchemaTemplateResult {
  result_value: Option<TSStatus>,
}

impl TSIServiceUnsetSchemaTemplateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TSIServiceUnsetSchemaTemplateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<TSStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = TSStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TSIServiceUnsetSchemaTemplateResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TSIServiceUnsetSchemaTemplateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<TSStatus> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for TSIServiceUnsetSchemaTemplate"
          )
        )
      )
    }
  }
}

